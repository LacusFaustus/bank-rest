openapi: 3.0.3
info:
  title: Bank REST API
  description: Bank Card Management System API with JWT authentication
  version: 1.0.0
  contact:
    name: Bank Support
    email: support@bank.com

servers:
  - url: http://localhost:8080
    description: Development server

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    AuthRequest:
      type: object
      required:
        - username
        - password
      properties:
        username:
          type: string
          example: "admin"
        password:
          type: string
          example: "admin123"

    AuthResponse:
      type: object
      properties:
        accessToken:
          type: string
        tokenType:
          type: string
          example: "Bearer"

    CardResponse:
      type: object
      properties:
        id:
          type: integer
        cardNumber:
          type: string
          example: "**** **** **** 1234"
        cardHolder:
          type: string
          example: "JOHN DOE"
        expiryDate:
          type: string
          format: date
        balance:
          type: number
          format: double
        status:
          type: string
          enum: [ACTIVE, BLOCKED, EXPIRED]
        userUsername:
          type: string
          example: "user1"

    CreateCardRequest:
      type: object
      required:
        - cardNumber
        - cardHolder
        - expiryDate
        - initialBalance
        - userId
      properties:
        cardNumber:
          type: string
          example: "1234567890123456"
        cardHolder:
          type: string
          example: "JOHN DOE"
        expiryDate:
          type: string
          format: date
        initialBalance:
          type: number
          format: double
          example: 1000.0
        userId:
          type: integer
          example: 1

    TransferRequest:
      type: object
      required:
        - fromCardId
        - toCardId
        - amount
      properties:
        fromCardId:
          type: integer
          example: 1
        toCardId:
          type: integer
          example: 2
        amount:
          type: number
          format: double
          example: 100.0

    ErrorResponse:
      type: object
      properties:
        timestamp:
          type: string
          format: date-time
        status:
          type: integer
        error:
          type: string
        message:
          type: string
        path:
          type: string

paths:
  /api/auth/login:
    post:
      tags:
        - Authentication
      summary: User login
      description: Authenticate user and return JWT token
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AuthRequest'
      responses:
        '200':
          description: Successful authentication
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuthResponse'
        '401':
          description: Invalid credentials
        '400':
          description: Validation error

  /api/auth/validate:
    post:
      tags:
        - Authentication
      summary: Validate JWT token
      description: Check if the provided JWT token is valid
      security:
        - bearerAuth: []
      responses:
        '200':
          description: Token is valid
        '400':
          description: Invalid token

  /api/cards:
    get:
      tags:
        - Cards
      summary: Get user cards
      description: Retrieve paginated list of user's cards with optional search
      security:
        - bearerAuth: []
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 0
        - name: size
          in: query
          schema:
            type: integer
            default: 10
        - name: search
          in: query
          schema:
            type: string
      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                type: object
                properties:
                  content:
                    type: array
                    items:
                      $ref: '#/components/schemas/CardResponse'
                  totalPages:
                    type: integer
                  totalElements:
                    type: integer
                  size:
                    type: integer
                  number:
                    type: integer
        '401':
          description: Unauthorized

  /api/cards/{cardId}:
    get:
      tags:
        - Cards
      summary: Get card by ID
      description: Retrieve specific card details
      security:
        - bearerAuth: []
      parameters:
        - name: cardId
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CardResponse'
        '404':
          description: Card not found
        '403':
          description: Access denied

  /api/cards/transfer:
    post:
      tags:
        - Cards
      summary: Transfer between cards
      description: Transfer money between user's own cards
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TransferRequest'
      responses:
        '200':
          description: Transfer completed successfully
        '400':
          description: Validation error or insufficient balance
        '403':
          description: Access denied

  /api/cards/{cardId}/block-request:
    post:
      tags:
        - Cards
      summary: Request card block
      description: User requests to block their card
      security:
        - bearerAuth: []
      parameters:
        - name: cardId
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: Block request submitted
        '404':
          description: Card not found
        '403':
          description: Access denied

  /api/admin/cards:
    get:
      tags:
        - Admin
      summary: Get all cards
      description: Retrieve paginated list of all cards (Admin only)
      security:
        - bearerAuth: []
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 0
        - name: size
          in: query
          schema:
            type: integer
            default: 10
      responses:
        '200':
          description: Successful operation
          content:
            application/json:
              schema:
                type: object
                properties:
                  content:
                    type: array
                    items:
                      $ref: '#/components/schemas/CardResponse'
                  totalPages:
                    type: integer
                  totalElements:
                    type: integer
                  size:
                    type: integer
                  number:
                    type: integer
        '403':
          description: Admin access required

    post:
      tags:
        - Admin
      summary: Create new card
      description: Create a new bank card (Admin only)
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateCardRequest'
      responses:
        '201':
          description: Card created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CardResponse'
        '400':
          description: Validation error
        '403':
          description: Admin access required

  /api/admin/cards/{cardId}:
    delete:
      tags:
        - Admin
      summary: Delete card
      description: Delete a card (Admin only)
      security:
        - bearerAuth: []
      parameters:
        - name: cardId
          in: path
          required: true
          schema:
            type: integer
      responses:
        '200':
          description: Card deleted successfully
        '404':
          description: Card not found
        '403':
          description: Admin access required

  /api/admin/cards/{cardId}/status:
    put:
      tags:
        - Admin
      summary: Update card status
      description: Update card status (Admin only)
      security:
        - bearerAuth: []
      parameters:
        - name: cardId
          in: path
          required: true
          schema:
            type: integer
        - name: status
          in: query
          required: true
          schema:
            type: string
            enum: [ACTIVE, BLOCKED]
      responses:
        '200':
          description: Status updated successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CardResponse'
        '404':
          description: Card not found
        '403':
          description: Admin access required

security:
  - bearerAuth: []


package com.bank.aspect;

import com.bank.service.MonitoringService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;

@Slf4j
@Aspect
@Component
@RequiredArgsConstructor
public class LoggingAspect {

    private final MonitoringService monitoringService;

    @Around("execution(* com.bank.service.CardService.transferBetweenCards(..))")
    public Object logTransferOperation(ProceedingJoinPoint joinPoint) throws Throwable {
        String username = getCurrentUsername();
        Object[] args = joinPoint.getArgs();
        Long fromCardId = (Long) args[1];
        Long toCardId = (Long) args[2];
        BigDecimal amount = (BigDecimal) args[3];

        log.info("üîÑ Transfer initiated by {}: {} from card {} to card {}",
                username, amount, fromCardId, toCardId);

        long startTime = System.currentTimeMillis();
        try {
            Object result = joinPoint.proceed();
            long duration = System.currentTimeMillis() - startTime;

            log.info("‚úÖ Transfer completed by {}: {} from card {} to card {} ({} ms)",
                    username, amount, fromCardId, toCardId, duration);

            monitoringService.recordTransfer(username, "target_user", amount);
            return result;
        } catch (Exception e) {
            log.error("‚ùå Transfer failed by {}: {} from card {} to card {} - Error: {}",
                    username, amount, fromCardId, toCardId, e.getMessage());
            throw e;
        }
    }

    @Around("execution(* com.bank.controller.AuthController.authenticateUser(..))")
    public Object logAuthentication(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        try {
            Object result = joinPoint.proceed();
            long duration = System.currentTimeMillis() - startTime;

            log.debug("üîê Authentication completed in {} ms", duration);
            return result;
        } catch (Exception e) {
            monitoringService.recordFailedLogin("unknown");
            throw e;
        }
    }

    private String getCurrentUsername() {
        try {
            return SecurityContextHolder.getContext().getAuthentication().getName();
        } catch (Exception e) {
            return "SYSTEM";
        }
    }
}


package com.bank.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@EnableAspectJAutoProxy
public class AopConfig {
}


package com.bank.config;

import com.bank.interceptor.RateLimitInterceptor;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@RequiredArgsConstructor
public class AppConfig implements WebMvcConfigurer {

    private final RateLimitInterceptor rateLimitInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(rateLimitInterceptor)
                .addPathPatterns("/api/**")
                .excludePathPatterns("/api/auth/validate"); // –ò—Å–∫–ª—é—á–∞–µ–º validate –∏–∑ rate limiting
    }
}


package com.bank.config;

import com.bank.entity.Card;
import com.bank.entity.User;
import com.bank.repository.CardRepository;
import com.bank.repository.UserRepository;
import com.bank.service.EncryptionService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;

// –í—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ç–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
// @Component
// @Profile("local")
@RequiredArgsConstructor
@Slf4j
public class DataInitializer implements CommandLineRunner {

    private final UserRepository userRepository;
    private final CardRepository cardRepository;
    private final PasswordEncoder passwordEncoder;
    private final EncryptionService encryptionService;

    @Override
    @Transactional
    public void run(String... args) throws Exception {
        log.info("Data initializer is temporarily disabled for debugging");

        // –í—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–µ–º –≤—Å—é –ª–æ–≥–∏–∫—É –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        /*
        log.info("Initializing data for local development...");

        // –°–æ–∑–¥–∞–µ–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
        if (userRepository.findByUsername("admin").isEmpty()) {
            User admin = User.builder()
                    .username("admin")
                    .password(passwordEncoder.encode("admin123"))
                    .email("admin@bank.com")
                    .role(User.Role.ROLE_ADMIN)
                    .build();
            userRepository.save(admin);
            log.info("Admin user created: admin/admin123");

            // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
            String encryptedCardNumber = encryptionService.encrypt("1234567890123456");
            log.debug("Encrypted card number length: {}", encryptedCardNumber.length());

            Card adminCard = Card.builder()
                    .cardNumber(encryptedCardNumber)
                    .cardHolder("ADMIN USER")
                    .expiryDate(LocalDate.now().plusYears(2))
                    .balance(new BigDecimal("10000.00"))
                    .status(Card.CardStatus.ACTIVE)
                    .user(admin)
                    .build();
            cardRepository.save(adminCard);
            log.info("Admin card created with number: **** **** **** 3456");
        }

        // –°–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if (userRepository.findByUsername("user1").isEmpty()) {
            User user = User.builder()
                    .username("user1")
                    .password(passwordEncoder.encode("user123"))
                    .email("user1@bank.com")
                    .role(User.Role.ROLE_USER)
                    .build();
            userRepository.save(user);
            log.info("User created: user1/user123");

            // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            String encryptedCardNumber = encryptionService.encrypt("9876543210987654");
            Card userCard = Card.builder()
                    .cardNumber(encryptedCardNumber)
                    .cardHolder("USER ONE")
                    .expiryDate(LocalDate.now().plusYears(1))
                    .balance(new BigDecimal("5000.00"))
                    .status(Card.CardStatus.ACTIVE)
                    .user(user)
                    .build();
            cardRepository.save(userCard);
            log.info("User card created with number: **** **** **** 7654");
        }

        log.info("Data initialization completed");

        // –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –¥–ª—è –¥–æ—Å—Ç—É–ø–∞
        log.info("=== Local Development Info ===");
        log.info("H2 Console: http://localhost:8080/h2-console");
        log.info("JDBC URL: jdbc:h2:mem:bankdb");
        log.info("Username: sa");
        log.info("Password: (empty)");
        log.info("Swagger UI: http://localhost:8080/swagger-ui.html");
        log.info("=== Available Users ===");
        log.info("Admin: admin/admin123");
        log.info("User: user1/user123");
        log.info("==============================");
        */
    }
}



package com.bank.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.event.ApplicationEventMulticaster;
import org.springframework.context.event.SimpleApplicationEventMulticaster;
import org.springframework.core.task.SimpleAsyncTaskExecutor;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync
public class EventConfig {

    @Bean(name = "applicationEventMulticaster")
    public ApplicationEventMulticaster simpleApplicationEventMulticaster() {
        SimpleApplicationEventMulticaster eventMulticaster = new SimpleApplicationEventMulticaster();
        eventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor());
        return eventMulticaster;
    }
}


package com.bank.config;

import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonConfig {

    @Bean
    public JavaTimeModule javaTimeModule() {
        return new JavaTimeModule();
    }
}


package com.bank.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Bank Card Management API")
                        .version("1.0.0")
                        .description("REST API for managing bank cards with JWT authentication")
                        .contact(new Contact()
                                .name("Bank API Support")
                                .email("api-support@bank.com")
                                .url("https://bank.com/api"))
                        .license(new License()
                                .name("Apache 2.0")
                                .url("https://www.apache.org/licenses/LICENSE-2.0")))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new io.swagger.v3.oas.models.Components()
                        .addSecuritySchemes("bearerAuth", new SecurityScheme()
                                .name("bearerAuth")
                                .type(SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")
                                .description("JWT token obtained from authentication endpoint")));
    }
}



package com.bank.config;

import org.springframework.cache.CacheManager;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RateLimitConfig {

    @Bean
    public CacheManager rateLimitCacheManager() {
        return new ConcurrentMapCacheManager("rateLimit");
    }
}


package com.bank.config;

import com.bank.security.JwtAuthenticationFilter;
import com.bank.security.JwtAuthenticationEntryPoint;
import com.bank.security.JwtTokenProvider;
import com.bank.security.CustomUserDetailsService;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationEntryPoint unauthorizedHandler;
    private final CustomUserDetailsService userDetailsService;
    private final JwtTokenProvider tokenProvider;

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter(tokenProvider, userDetailsService);
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .exceptionHandling(exception -> exception
                        .authenticationEntryPoint(unauthorizedHandler)
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/api/auth/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**", "/swagger-ui.html").permitAll()
                        .requestMatchers("/h2-console/**").permitAll()
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        .anyRequest().authenticated()
                );

        // –î–ª—è H2 console –≤ —Ç–µ—Å—Ç–æ–≤–æ–π —Å—Ä–µ–¥–µ
        http.headers(headers -> headers.frameOptions(frame -> frame.sameOrigin()));

        http.authenticationProvider(authenticationProvider());
        http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}


package com.bank.config;

import com.bank.entity.User;
import com.bank.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Profile;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

@Component
@Profile("local")
@RequiredArgsConstructor
@Slf4j
public class SimpleDataInitializer implements CommandLineRunner {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    @Override
    public void run(String... args) throws Exception {
        log.info("Creating test users...");

        // –°–æ–∑–¥–∞–µ–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
        if (userRepository.findByUsername("admin").isEmpty()) {
            User admin = User.builder()
                    .username("admin")
                    .password(passwordEncoder.encode("admin123"))
                    .email("admin@bank.com")
                    .role(User.Role.ROLE_ADMIN)
                    .build();
            userRepository.save(admin);
            log.info("‚úÖ Admin user created: admin/admin123");
        }

        // –°–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if (userRepository.findByUsername("user1").isEmpty()) {
            User user = User.builder()
                    .username("user1")
                    .password(passwordEncoder.encode("user123"))
                    .email("user1@bank.com")
                    .role(User.Role.ROLE_USER)
                    .build();
            userRepository.save(user);
            log.info("‚úÖ User created: user1/user123");
        }

        log.info("‚úÖ Test users created successfully");
        log.info("=== Test Credentials ===");
        log.info("Admin: admin/admin123");
        log.info("User:  user1/user123");
        log.info("=========================");
    }
}


package com.bank.controller;

import com.bank.dto.CardResponseDTO;
import com.bank.dto.CreateCardRequest;
import com.bank.entity.Card;
import com.bank.entity.User;
import com.bank.service.CardService;
import com.bank.service.EncryptionService;
import com.bank.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin")
@PreAuthorize("hasRole('ADMIN')")
@RequiredArgsConstructor
public class AdminController {

    private final CardService cardService;
    private final UserService userService;
    private final EncryptionService encryptionService;

    @PostMapping("/cards")
    public ResponseEntity<CardResponseDTO> createCard(@Valid @RequestBody CreateCardRequest request) {
        User user = userService.getUserById(request.getUserId());

        // –®–∏—Ñ—Ä—É–µ–º –Ω–æ–º–µ—Ä –∫–∞—Ä—Ç—ã
        String encryptedCardNumber = encryptionService.encrypt(request.getCardNumber());

        Card card = Card.builder()
                .cardNumber(encryptedCardNumber)
                .cardHolder(request.getCardHolder().toUpperCase())
                .expiryDate(request.getExpiryDate())
                .balance(request.getInitialBalance())
                .status(Card.CardStatus.ACTIVE)
                .user(user)
                .build();

        Card savedCard = cardService.createCard(card);

        CardResponseDTO response = CardResponseDTO.fromEntity(
                savedCard,
                cardService.getMaskedCardNumber(savedCard.getCardNumber())
        );

        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @PutMapping("/cards/{cardId}/status")
    public ResponseEntity<CardResponseDTO> updateCardStatus(
            @PathVariable Long cardId,
            @RequestParam Card.CardStatus status) {

        Card card = cardService.updateCardStatus(cardId, status);

        CardResponseDTO response = CardResponseDTO.fromEntity(
                card,
                cardService.getMaskedCardNumber(card.getCardNumber())
        );

        return ResponseEntity.ok(response);
    }

    @GetMapping("/cards")
    public ResponseEntity<Page<CardResponseDTO>> getAllCards(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Page<Card> cards = cardService.getAllCards(PageRequest.of(page, size));

        Page<CardResponseDTO> response = cards.map(card ->
                CardResponseDTO.fromEntity(
                        card,
                        cardService.getMaskedCardNumber(card.getCardNumber())
                )
        );

        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/cards/{cardId}")
    public ResponseEntity<?> deleteCard(@PathVariable Long cardId) {
        cardService.deleteCard(cardId);
        return ResponseEntity.ok().body("Card deleted successfully");
    }

    @GetMapping("/users")
    public ResponseEntity<Page<User>> getAllUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        Page<User> users = userService.getAllUsers(PageRequest.of(page, size));
        return ResponseEntity.ok(users);
    }
}


package com.bank.controller;

import com.bank.dto.PaginatedResponse;
import com.bank.entity.AuditLog;
import com.bank.repository.AuditLogRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;

@RestController
@RequestMapping("/api/admin/audit")
@PreAuthorize("hasRole('ADMIN')")
@RequiredArgsConstructor
public class AuditController {

    private final AuditLogRepository auditLogRepository;

    @GetMapping
    public ResponseEntity<PaginatedResponse<AuditLog>> getAuditLogs(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "50") int size,
            @RequestParam(required = false) String username,
            @RequestParam(required = false) String actionType,
            @RequestParam(required = false) Boolean success,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate) {

        if (startDate == null) startDate = LocalDateTime.now().minusDays(7);
        if (endDate == null) endDate = LocalDateTime.now();

        Page<AuditLog> auditLogs = auditLogRepository.findWithFilters(
                username, actionType, success, startDate, endDate, PageRequest.of(page, size));

        return ResponseEntity.ok(PaginatedResponse.of(auditLogs));
    }

    @GetMapping("/user/{username}")
    public ResponseEntity<PaginatedResponse<AuditLog>> getUserAuditLogs(
            @PathVariable String username,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "50") int size) {

        Page<AuditLog> auditLogs = auditLogRepository.findByUsername(
                username, PageRequest.of(page, size));

        return ResponseEntity.ok(PaginatedResponse.of(auditLogs));
    }
}


package com.bank.controller;

import com.bank.dto.AuthRequest;
import com.bank.dto.AuthResponse;
import com.bank.security.JwtTokenProvider;
import com.bank.service.AuditService;
import com.bank.service.MonitoringService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final MonitoringService monitoringService;
    private final AuditService auditService;

    @PostMapping("/login")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody AuthRequest loginRequest,
                                              HttpServletRequest request) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsername(),
                            loginRequest.getPassword()
                    )
            );

            SecurityContextHolder.getContext().setAuthentication(authentication);
            String jwt = tokenProvider.generateToken(authentication);

            // –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω—É—é –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
            auditService.logSecurityEvent("LOGIN_SUCCESS",
                    "User authenticated successfully", true, request);
            monitoringService.recordSuccessfulLogin(loginRequest.getUsername());

            return ResponseEntity.ok(new AuthResponse(jwt, "Bearer"));
        } catch (BadCredentialsException e) {
            // –õ–æ–≥–∏—Ä—É–µ–º –Ω–µ—É–¥–∞—á–Ω—É—é –ø–æ–ø—ã—Ç–∫—É –≤—Ö–æ–¥–∞
            auditService.logSecurityEvent("LOGIN_FAILED",
                    "Invalid credentials", false, request);
            monitoringService.recordFailedLogin(loginRequest.getUsername());

            return ResponseEntity.status(401).body("Invalid credentials");
        }
    }

    @PostMapping("/validate")
    public ResponseEntity<?> validateToken(@RequestHeader(value = "Authorization", required = false) String token,
                                           HttpServletRequest request) {
        if (token == null || !token.startsWith("Bearer ")) {
            auditService.logSecurityEvent("TOKEN_VALIDATION_FAILED",
                    "Invalid token format", false, request);
            return ResponseEntity.badRequest().body("Invalid token");
        }

        String jwt = token.substring(7);
        if (tokenProvider.validateToken(jwt)) {
            auditService.logSecurityEvent("TOKEN_VALIDATION_SUCCESS",
                    "Token is valid", true, request);
            return ResponseEntity.ok().body("Token is valid");
        }

        auditService.logSecurityEvent("TOKEN_VALIDATION_FAILED",
                "Invalid token", false, request);
        return ResponseEntity.badRequest().body("Invalid token");
    }
}


package com.bank.controller;

import com.bank.dto.CardResponseDTO;
import com.bank.dto.TransferRequest;
import com.bank.entity.Card;
import com.bank.entity.User;
import com.bank.service.CardService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;

@RestController
@RequestMapping("/api/cards")
@RequiredArgsConstructor
public class CardController {

    private final CardService cardService;

    @GetMapping
    public ResponseEntity<Page<CardResponseDTO>> getUserCards(
            @AuthenticationPrincipal User user,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String search) {

        Page<Card> cards = cardService.getUserCards(user, PageRequest.of(page, size), search);

        Page<CardResponseDTO> response = cards.map(card ->
                CardResponseDTO.fromEntity(
                        card,
                        cardService.getMaskedCardNumber(card.getCardNumber())
                )
        );

        return ResponseEntity.ok(response);
    }

    @GetMapping("/{cardId}")
    public ResponseEntity<CardResponseDTO> getCard(
            @AuthenticationPrincipal User user,
            @PathVariable Long cardId) {

        Card card = cardService.getCardById(cardId, user);
        CardResponseDTO response = CardResponseDTO.fromEntity(
                card,
                cardService.getMaskedCardNumber(card.getCardNumber())
        );

        return ResponseEntity.ok(response);
    }

    @PostMapping("/{cardId}/block-request")
    public ResponseEntity<?> requestBlockCard(
            @AuthenticationPrincipal User user,
            @PathVariable Long cardId) {

        cardService.requestCardBlock(cardId, user);

        return ResponseEntity.ok().body("Block request submitted for card: " + cardId + ". Please contact administrator.");
    }

    @PostMapping("/transfer")
    public ResponseEntity<?> transferBetweenCards(
            @AuthenticationPrincipal User user,
            @Valid @RequestBody TransferRequest request) {

        cardService.transferBetweenCards(user, request.getFromCardId(),
                request.getToCardId(), request.getAmount());

        return ResponseEntity.ok().body("Transfer completed successfully");
    }

    @GetMapping("/{cardId}/balance")
    public ResponseEntity<BigDecimal> getCardBalance(
            @AuthenticationPrincipal User user,
            @PathVariable Long cardId) {

        Card card = cardService.getCardById(cardId, user);
        return ResponseEntity.ok(card.getBalance());
    }
}


package com.bank.controller;

import com.bank.service.MonitoringService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@RestController
@RequestMapping("/api/admin/monitoring")
@PreAuthorize("hasRole('ADMIN')")
@RequiredArgsConstructor
public class MonitoringController {

    private final MonitoringService monitoringService;

    @GetMapping("/metrics")
    public ResponseEntity<Map<String, Long>> getMetrics() {
        ConcurrentHashMap<String, Long> metrics = new ConcurrentHashMap<>();
        monitoringService.getAllMetrics().forEach((key, value) -> metrics.put(key, value.get()));

        return ResponseEntity.ok(metrics);
    }

    @GetMapping("/health")
    public ResponseEntity<Map<String, Object>> getHealth() {
        Map<String, Object> health = Map.of(
                "status", "UP",
                "timestamp", System.currentTimeMillis(),
                "memoryUsage", getMemoryUsage()
        );

        return ResponseEntity.ok(health);
    }

    private Map<String, Object> getMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        long maxMemory = runtime.maxMemory();
        double memoryUsagePercent = (double) usedMemory / maxMemory * 100;

        return Map.of(
                "usedMemoryMB", usedMemory / (1024 * 1024),
                "maxMemoryMB", maxMemory / (1024 * 1024),
                "usagePercent", String.format("%.2f%%", memoryUsagePercent)
        );
    }
}


package com.bank.controller;

import com.bank.service.TransactionReportService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

@RestController
@RequestMapping("/api/reports")
@RequiredArgsConstructor
public class ReportController {

    private final TransactionReportService transactionReportService;

    @GetMapping("/daily")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Map<String, Object>> getDailyReport() {
        Map<String, Object> report = transactionReportService.getDailyTransactionReport();
        return ResponseEntity.ok(report);
    }

    @GetMapping("/my-stats")
    public ResponseEntity<Map<String, Object>> getUserStats(@AuthenticationPrincipal com.bank.entity.User user) {
        Map<String, Object> stats = transactionReportService.getUserTransactionStats(user.getId());
        return ResponseEntity.ok(stats);
    }

    @GetMapping("/health")
    public ResponseEntity<Map<String, String>> healthCheck() {
        return ResponseEntity.ok(Map.of("status", "OK", "service", "Bank REST API"));
    }
}


package com.bank.controller;

import com.bank.entity.User;
import com.bank.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/user")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @GetMapping("/profile")
    public ResponseEntity<User> getUserProfile(@AuthenticationPrincipal User user) {
        User currentUser = userService.getUserByUsername(user.getUsername());
        // –ù–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–∞—Ä–æ–ª—å –≤ –æ—Ç–≤–µ—Ç–µ
        currentUser.setPassword(null);
        return ResponseEntity.ok(currentUser);
    }

    @GetMapping("/profile/{userId}")
    public ResponseEntity<User> getUserById(@PathVariable Long userId, @AuthenticationPrincipal User currentUser) {
        // –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω –º–æ–∂–µ—Ç —Å–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–æ—Ñ–∏–ª–∏ –¥—Ä—É–≥–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        if (!currentUser.getRole().equals(User.Role.ROLE_ADMIN)) {
            return ResponseEntity.status(403).build();
        }

        User user = userService.getUserById(userId);
        user.setPassword(null);
        return ResponseEntity.ok(user);
    }
}


package com.bank.dto;

import com.bank.validation.StrongPassword;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class AuthRequest {
    @NotBlank(message = "Username is required")
    private String username;

    @NotBlank(message = "Password is required")
    @StrongPassword
    private String password;
}


package com.bank.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class AuthResponse {
    private String accessToken;
    private String tokenType;
}


package com.bank.dto;

import com.bank.entity.Card;
import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.Builder;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@Builder
public class CardResponseDTO {
    private Long id;
    private String cardNumber;
    private String cardHolder;

    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate expiryDate;

    private BigDecimal balance;
    private Card.CardStatus status;
    private String userUsername;

    public static CardResponseDTO fromEntity(Card card, String maskedCardNumber) {
        return CardResponseDTO.builder()
                .id(card.getId())
                .cardNumber(maskedCardNumber)
                .cardHolder(card.getCardHolder())
                .expiryDate(card.getExpiryDate())
                .balance(card.getBalance())
                .status(card.getStatus())
                .userUsername(card.getUser() != null ? card.getUser().getUsername() : null)
                .build();
    }
}


package com.bank.dto;

import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;

@Data
public class CreateCardRequest {
    @NotBlank(message = "Card number is required")
    @Pattern(regexp = "\\d{16}", message = "Card number must be 16 digits")
    private String cardNumber;

    @NotBlank(message = "Card holder is required")
    @Size(min = 2, max = 100, message = "Card holder name must be between 2 and 100 characters")
    private String cardHolder;

    @NotNull(message = "Expiry date is required")
    @Future(message = "Expiry date must be in the future")
    private LocalDate expiryDate;

    @NotNull(message = "Initial balance is required")
    @DecimalMin(value = "0.0", message = "Balance must be positive")
    private BigDecimal initialBalance;

    @NotNull(message = "User ID is required")
    private Long userId;
}


package com.bank.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.time.LocalDateTime;

@Data
@AllArgsConstructor
public class ErrorResponse {
    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
}


package com.bank.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.domain.Page;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PaginatedResponse<T> {
    private List<T> content;
    private PaginationMetadata pagination;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PaginationMetadata {
        private int currentPage;
        private int pageSize;
        private long totalElements;
        private int totalPages;
        private boolean first;
        private boolean last;
    }

    public static <T> PaginatedResponse<T> of(Page<T> page) {
        PaginationMetadata metadata = new PaginationMetadata(
                page.getNumber(),
                page.getSize(),
                page.getTotalElements(),
                page.getTotalPages(),
                page.isFirst(),
                page.isLast()
        );
        return new PaginatedResponse<>(page.getContent(), metadata);
    }
}


package com.bank.dto;

import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;

@Data
public class TransferRequest {
    @NotNull(message = "Source card ID is required")
    private Long fromCardId;

    @NotNull(message = "Destination card ID is required")
    private Long toCardId;

    @NotNull(message = "Amount is required")
    @DecimalMin(value = "0.01", message = "Amount must be greater than 0")
    private BigDecimal amount;
}


package com.bank.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(name = "audit_logs")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AuditLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 50)
    private String actionType; // LOGIN, TRANSFER, CARD_CREATE, etc.

    @Column(nullable = false, length = 500)
    private String description;

    @Column(nullable = false, length = 100)
    private String username;

    @Column(length = 45)
    private String ipAddress;

    @Column(length = 500)
    private String userAgent;

    @Column(nullable = false)
    private boolean success;

    @Column(length = 1000)
    private String errorMessage;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime timestamp;

    @Column(length = 50)
    private String resourceId; // Card ID, Transaction ID, etc.

    @Column(length = 1000)
    private String requestDetails; // JSON with request details
}


package com.bank.entity;

import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "cards")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Card {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "card_number", nullable = false, length = 255)
    private String cardNumber;

    @Column(name = "card_holder", nullable = false, length = 100)
    private String cardHolder;

    @Column(name = "expiry_date", nullable = false)
    private LocalDate expiryDate;

    @Column(nullable = false, precision = 15, scale = 2)
    private BigDecimal balance;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private CardStatus status;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private User user;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Builder.Default
    @Column(name = "block_requested")
    private Boolean blockRequested = false;

    public enum CardStatus {
        ACTIVE, BLOCKED, EXPIRED
    }

    public boolean isActive() {
        return status == CardStatus.ACTIVE && !isExpired();
    }

    public boolean isExpired() {
        return expiryDate.isBefore(LocalDate.now());
    }

    public boolean isBlocked() {
        return status == CardStatus.BLOCKED;
    }
}


package com.bank.entity;

import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "transactions")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Transaction {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "from_card_id")
    private Card fromCard;

    @ManyToOne
    @JoinColumn(name = "to_card_id")
    private Card toCard;

    @Column(nullable = false, precision = 15, scale = 2)
    private BigDecimal amount;

    @CreationTimestamp
    private LocalDateTime transactionDate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private TransactionStatus status;

    public enum TransactionStatus {
        SUCCESS, FAILED, PENDING
    }
}


package com.bank.entity;

import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.Collection;
import java.util.List;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User implements UserDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false, length = 50)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(unique = true, nullable = false, length = 100)
    private String email;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private Role role;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @ToString.Exclude
    @EqualsAndHashCode.Exclude
    private List<Card> cards;

    public enum Role {
        ROLE_USER, ROLE_ADMIN
    }

    // UserDetails methods
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority(role.name()));
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}


package com.bank.event.handler;

import com.bank.entity.Card;
import com.bank.event.CardBlockRequestedEvent;
import com.bank.repository.CardRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;

@Slf4j
@Component
@RequiredArgsConstructor
public class CardEventHandler {

    private final CardRepository cardRepository;

    @Async
    @EventListener
    public void handleCardBlockRequest(CardBlockRequestedEvent event) {
        Card card = event.getCard();
        String reason = event.getReason();

        log.info("üîÑ Processing card block request: Card {} for user {}, Reason: {}",
                card.getId(), card.getUser().getUsername(), reason);

        // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é —Å:
        // - Email —Å–µ—Ä–≤–∏—Å–æ–º –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
        // - –°–∏—Å—Ç–µ–º–æ–π —Ç–∏–∫–µ—Ç–æ–≤
        // - Slack/Teams —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏

        log.info("‚úÖ Card block request processed for card: {}", card.getId());
    }

    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleCardBlockRequestTransactional(CardBlockRequestedEvent event) {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ—Å–ª–µ –∫–æ–º–º–∏—Ç–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        log.info("üìß Sending notifications for card block request: {}", event.getCard().getId());
    }
}


package com.bank.event.handler;

import com.bank.event.CardBlockRequestedEvent;
import com.bank.event.TransferCompletedEvent;
import com.bank.event.UserActivityEvent;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
public class NotificationEventHandler {

    @Async
    @EventListener
    public void handleCardBlockRequest(CardBlockRequestedEvent event) {
        log.info("üîî Card block requested notification: Card {}, Reason: {}",
                event.getCard().getId(), event.getReason());

        // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å —Å:
        // - Email —Å–µ—Ä–≤–∏—Å–æ–º
        // - SMS —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏
        // - Slack/Teams webhooks
        // - –°–∏—Å—Ç–µ–º–æ–π —Ç–∏–∫–µ—Ç–æ–≤ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
    }

    @Async
    @EventListener
    public void handleTransferCompleted(TransferCompletedEvent event) {
        log.info("üîî Transfer completed: {} from card {} to card {}",
                event.getAmount(), event.getFromCard().getId(), event.getToCard().getId());

        // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ successful transfer
    }

    @Async
    @EventListener
    public void handleUserActivity(UserActivityEvent event) {
        log.info("üîî User activity: {} - {} from IP: {}",
                event.getUser().getUsername(), event.getActivityType(), event.getIpAddress());

        // –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        if ("FAILED_LOGIN".equals(event.getActivityType())) {
            log.warn("‚ö†Ô∏è Failed login attempt for user: {} from IP: {}",
                    event.getUser().getUsername(), event.getIpAddress());
        }
    }
}


package com.bank.event;

import com.bank.entity.Card;
import lombok.Getter;
import org.springframework.context.ApplicationEvent;

@Getter
public class CardBlockRequestedEvent extends ApplicationEvent {
    private final Card card;
    private final String reason;

    public CardBlockRequestedEvent(Object source, Card card, String reason) {
        super(source);
        this.card = card;
        this.reason = reason;
    }
}


package com.bank.event;

import com.bank.entity.Card;
import com.bank.entity.Transaction;
import lombok.Getter;
import org.springframework.context.ApplicationEvent;

import java.math.BigDecimal;

@Getter
public class TransferCompletedEvent extends ApplicationEvent {
    private final Transaction transaction;
    private final Card fromCard;
    private final Card toCard;
    private final BigDecimal amount;

    public TransferCompletedEvent(Object source, Transaction transaction, Card fromCard, Card toCard, BigDecimal amount) {
        super(source);
        this.transaction = transaction;
        this.fromCard = fromCard;
        this.toCard = toCard;
        this.amount = amount;
    }
}


package com.bank.event;

import com.bank.entity.User;
import lombok.Getter;
import org.springframework.context.ApplicationEvent;

@Getter
public class UserActivityEvent extends ApplicationEvent {
    private final User user;
    private final String activityType;
    private final String description;
    private final String ipAddress;

    public UserActivityEvent(Object source, User user, String activityType, String description, String ipAddress) {
        super(source);
        this.user = user;
        this.activityType = activityType;
        this.description = description;
        this.ipAddress = ipAddress;
    }
}


package com.bank.exception;

public class CardAlreadyExistsException extends RuntimeException {
    public CardAlreadyExistsException(String message) {
        super(message);
    }
}


package com.bank.exception;

public class CardNotFoundException extends RuntimeException {
    public CardNotFoundException(String message) {
        super(message);
    }
}


package com.bank.exception;

import com.bank.dto.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(CardNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleCardNotFound(CardNotFoundException ex, WebRequest request) {
        ErrorResponse error = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(CardAlreadyExistsException.class)
    public ResponseEntity<ErrorResponse> handleCardAlreadyExists(CardAlreadyExistsException ex, WebRequest request) {
        ErrorResponse error = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(error, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(InsufficientBalanceException.class)
    public ResponseEntity<ErrorResponse> handleInsufficientBalance(InsufficientBalanceException ex, WebRequest request) {
        ErrorResponse error = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Bad Request",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(UnauthorizedAccessException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedAccess(UnauthorizedAccessException ex, WebRequest request) {
        ErrorResponse error = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(error, HttpStatus.FORBIDDEN);
    }

    @ExceptionHandler(UsernameNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UsernameNotFoundException ex, WebRequest request) {
        ErrorResponse error = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex, WebRequest request) {
        String errorMessage = ex.getBindingResult().getFieldErrors().stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .findFirst()
                .orElse("Validation error");

        ErrorResponse error = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.BAD_REQUEST.value(),
                "Validation Error",
                errorMessage,
                request.getDescription(false)
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex, WebRequest request) {
        ErrorResponse error = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                "Access denied",
                request.getDescription(false)
        );
        return new ResponseEntity<>(error, HttpStatus.FORBIDDEN);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGlobalException(Exception ex, WebRequest request) {
        ErrorResponse error = new ErrorResponse(
                LocalDateTime.now(),
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                ex.getMessage(),
                request.getDescription(false)
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


package com.bank.exception;

public class InsufficientBalanceException extends RuntimeException {
    public InsufficientBalanceException(String message) {
        super(message);
    }
}


package com.bank.exception;

public class UnauthorizedAccessException extends RuntimeException {
    public UnauthorizedAccessException(String message) {
        super(message);
    }
}


package com.bank.interceptor;

import com.bank.service.RateLimitService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

@Component
@RequiredArgsConstructor
public class RateLimitInterceptor implements HandlerInterceptor {

    private final RateLimitService rateLimitService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String clientIp = getClientIp(request);
        String endpoint = request.getRequestURI();

        // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ä–∞–∑–Ω—ã–µ –ª–∏–º–∏—Ç—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö endpoint-–æ–≤
        RateLimitService.RateLimitType rateLimitType = getRateLimitType(endpoint);

        if (rateLimitService.isRateLimited(clientIp + "_" + endpoint, rateLimitType)) {
            response.setStatus(429); // Too Many Requests
            response.getWriter().write("Rate limit exceeded. Please try again later.");
            return false;
        }

        rateLimitService.recordRequest(clientIp + "_" + endpoint, rateLimitType);
        return true;
    }

    private RateLimitService.RateLimitType getRateLimitType(String endpoint) {
        if (endpoint.contains("/auth/login")) {
            return RateLimitService.RateLimitType.LOGIN_ATTEMPT;
        } else if (endpoint.contains("/transfer")) {
            return RateLimitService.RateLimitType.TRANSFER_OPERATION;
        } else {
            return RateLimitService.RateLimitType.API_REQUEST;
        }
    }

    private String getClientIp(HttpServletRequest request) {
        String xfHeader = request.getHeader("X-Forwarded-For");
        if (xfHeader != null) {
            return xfHeader.split(",")[0];
        }
        return request.getRemoteAddr();
    }
}


package com.bank.repository;

import com.bank.entity.AuditLog;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;

@Repository
public interface AuditLogRepository extends JpaRepository<AuditLog, Long> {

    Page<AuditLog> findByUsername(String username, Pageable pageable);

    Page<AuditLog> findByActionType(String actionType, Pageable pageable);

    Page<AuditLog> findByTimestampBetween(LocalDateTime start, LocalDateTime end, Pageable pageable);

    @Query("SELECT a FROM AuditLog a WHERE " +
            "(:username IS NULL OR a.username = :username) AND " +
            "(:actionType IS NULL OR a.actionType = :actionType) AND " +
            "(:success IS NULL OR a.success = :success) AND " +
            "a.timestamp BETWEEN :startDate AND :endDate")
    Page<AuditLog> findWithFilters(@Param("username") String username,
                                   @Param("actionType") String actionType,
                                   @Param("success") Boolean success,
                                   @Param("startDate") LocalDateTime startDate,
                                   @Param("endDate") LocalDateTime endDate,
                                   Pageable pageable);

    @Query("SELECT COUNT(a) FROM AuditLog a WHERE a.username = :username AND a.timestamp > :since")
    long countRecentActionsByUser(@Param("username") String username,
                                  @Param("since") LocalDateTime since);
}


package com.bank.repository;

import com.bank.entity.Card;
import com.bank.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface CardRepository extends JpaRepository<Card, Long> {
    Page<Card> findByUser(User user, Pageable pageable);

    @Query("SELECT c FROM Card c WHERE c.user = :user AND " +
            "(LOWER(c.cardHolder) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "CAST(c.id AS string) LIKE CONCAT('%', :search, '%'))")
    Page<Card> findByUserAndSearch(@Param("user") User user,
                                   @Param("search") String search,
                                   Pageable pageable);

    List<Card> findByUserAndStatus(User user, Card.CardStatus status);

    List<Card> findByStatusAndExpiryDateBefore(Card.CardStatus status, LocalDate expiryDate);

    @Query("SELECT c FROM Card c WHERE c.user = :user AND c.status = 'ACTIVE' AND c.expiryDate > CURRENT_DATE")
    List<Card> findActiveUserCards(User user);

    Page<Card> findAll(Pageable pageable);

    Optional<Card> findByIdAndUser(Long id, User user);

    boolean existsByCardNumber(String cardNumber);

    @Query("SELECT COUNT(c) > 0 FROM Card c WHERE c.id = :cardId AND c.user.id = :userId")
    boolean existsByIdAndUserId(@Param("cardId") Long cardId, @Param("userId") Long userId);

    List<Card> findByBlockRequestedTrue();

    // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ - —É–±–∏—Ä–∞–µ–º —Å–ª–æ–∂–Ω—ã–π boolean expression
    @Query("SELECT c FROM Card c WHERE " +
            "(:status IS NULL OR c.status = :status) AND " +
            "(:userId IS NULL OR c.user.id = :userId)")
    Page<Card> findWithFilters(@Param("status") Card.CardStatus status,
                               @Param("userId") Long userId,
                               Pageable pageable);

    // –û—Ç–¥–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –∫–∞—Ä—Ç
    @Query("SELECT c FROM Card c WHERE c.expiryDate < CURRENT_DATE")
    Page<Card> findExpiredCards(Pageable pageable);

    // –û—Ç–¥–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö –Ω–µ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –∫–∞—Ä—Ç
    @Query("SELECT c FROM Card c WHERE c.expiryDate >= CURRENT_DATE AND c.status = 'ACTIVE'")
    Page<Card> findActiveNonExpiredCards(Pageable pageable);

    @Query("SELECT COUNT(c) FROM Card c WHERE c.user.id = :userId AND c.status = 'ACTIVE'")
    long countActiveCardsByUserId(@Param("userId") Long userId);

    // –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –∏–º–µ–Ω–∏ –¥–µ—Ä–∂–∞—Ç–µ–ª—è –∫–∞—Ä—Ç—ã
    default Page<Card> findByUserAndCardHolderContainingIgnoreCase(User user, String search, Pageable pageable) {
        return findByUserAndSearch(user, search, pageable);
    }
}


package com.bank.repository;

import com.bank.entity.Transaction;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {

    @Query("SELECT t FROM Transaction t WHERE t.fromCard.user.id = :userId OR t.toCard.user.id = :userId")
    List<Transaction> findByUserId(@Param("userId") Long userId);

    List<Transaction> findByTransactionDateBetween(LocalDateTime start, LocalDateTime end);

    @Query("SELECT COUNT(t) FROM Transaction t WHERE t.transactionDate BETWEEN :start AND :end")
    long countByTransactionDateBetween(@Param("start") LocalDateTime start,
                                       @Param("end") LocalDateTime end);

    @Query("SELECT COUNT(t) FROM Transaction t WHERE t.status = :status AND t.transactionDate BETWEEN :start AND :end")
    long countByStatusAndTransactionDateBetween(@Param("status") Transaction.TransactionStatus status,
                                                @Param("start") LocalDateTime start,
                                                @Param("end") LocalDateTime end);

    @Query("SELECT COALESCE(SUM(t.amount), 0) FROM Transaction t WHERE t.transactionDate BETWEEN :start AND :end")
    BigDecimal sumAmountByTransactionDateBetween(@Param("start") LocalDateTime start,
                                                 @Param("end") LocalDateTime end);

    @Query("SELECT COUNT(t) FROM Transaction t WHERE " +
            "(t.fromCard.user.id = :userId OR t.toCard.user.id = :userId) AND " +
            "t.transactionDate >= :since")
    long countByUserInLast30Days(@Param("userId") Long userId,
                                 @Param("since") LocalDateTime since);

    @Query("SELECT COALESCE(SUM(t.amount), 0) FROM Transaction t WHERE " +
            "(t.fromCard.user.id = :userId OR t.toCard.user.id = :userId) AND " +
            "t.transactionDate >= :since")
    BigDecimal sumAmountByUserInLast30Days(@Param("userId") Long userId,
                                           @Param("since") LocalDateTime since);

    @Query("SELECT t FROM Transaction t WHERE " +
            "(t.fromCard.user.id = :userId OR t.toCard.user.id = :userId) " +
            "ORDER BY t.transactionDate DESC")
    List<Transaction> findRecentTransactionsByUser(@Param("userId") Long userId);
}


package com.bank.repository;

import com.bank.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable; // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ò–ú–ü–û–†–¢
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    Boolean existsByUsername(String username);
    Boolean existsByEmail(String email);

    @Query("SELECT u FROM User u WHERE " +
            "(:search IS NULL OR LOWER(u.username) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(u.email) LIKE LOWER(CONCAT('%', :search, '%')))")
    Page<User> findWithSearch(@Param("search") String search, Pageable pageable);

    @Query("SELECT u FROM User u WHERE u.createdAt BETWEEN :startDate AND :endDate")
    Page<User> findUsersRegisteredBetween(@Param("startDate") LocalDateTime startDate,
                                          @Param("endDate") LocalDateTime endDate,
                                          Pageable pageable); // –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ü–ê–†–ê–ú–ï–¢–†
}


package com.bank.security;

import com.bank.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        var user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .authorities(user.getRole().name())
                .build();
    }
}


package com.bank.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException {

        response.setContentType("application/json");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", "Authentication failed");
        body.put("path", request.getServletPath());

        ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), body);
    }
}


package com.bank.security;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                String username = tokenProvider.getUsernameFromJWT(jwt);

                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                var authentication = new org.springframework.security.authentication.UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("Could not set user authentication in security context", ex);
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}


package com.bank.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.stream.Collectors;

@Component
@Slf4j
public class JwtTokenProvider {

    private final String jwtSecret;
    private final long jwtExpirationInMs;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥–ª—è —Ç–µ—Å—Ç–æ–≤
    public JwtTokenProvider() {
        this.jwtSecret = "test-secret-key-very-long-secret-key-for-testing-purposes-here";
        this.jwtExpirationInMs = 86400000;
    }

    public JwtTokenProvider(@Value("${jwt.secret:bank-rest-secret-key-2024-very-secure-and-long}") String jwtSecret,
                            @Value("${jwt.expiration:86400000}") long jwtExpirationInMs) {
        this.jwtSecret = jwtSecret;
        this.jwtExpirationInMs = jwtExpirationInMs;
    }

    private SecretKey getSigningKey() {
        // –°–æ–∑–¥–∞–µ–º –∫–ª—é—á –¥–ª–∏–Ω–æ–π 32 –±–∞–π—Ç–∞
        byte[] keyBytes;
        if (jwtSecret.length() < 32) {
            StringBuilder sb = new StringBuilder(jwtSecret);
            while (sb.length() < 32) {
                sb.append("0");
            }
            keyBytes = sb.substring(0, 32).getBytes();
        } else if (jwtSecret.length() > 32) {
            keyBytes = jwtSecret.substring(0, 32).getBytes();
        } else {
            keyBytes = jwtSecret.getBytes();
        }
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public String generateToken(Authentication authentication) {
        String username = authentication.getName();
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);

        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));

        return Jwts.builder()
                .setSubject(username)
                .claim("authorities", authorities)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public String getUsernameFromJWT(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();

        return claims.getSubject();
    }

    public boolean validateToken(String authToken) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(authToken);
            return true;
        } catch (MalformedJwtException ex) {
            log.error("Invalid JWT token");
        } catch (ExpiredJwtException ex) {
            log.error("Expired JWT token");
        } catch (UnsupportedJwtException ex) {
            log.error("Unsupported JWT token");
        } catch (IllegalArgumentException ex) {
            log.error("JWT claims string is empty");
        } catch (Exception ex) {
            log.error("JWT validation error: {}", ex.getMessage());
        }
        return false;
    }
}


package com.bank.service;

import com.bank.entity.AuditLog;
import com.bank.repository.AuditLogRepository;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Slf4j
@Service
@RequiredArgsConstructor
public class AuditService {

    private final AuditLogRepository auditLogRepository;

    @Transactional
    public void logActivity(String actionType, String description, boolean success,
                            String resourceId, String requestDetails, HttpServletRequest request) {

        String username = getCurrentUsername();
        String ipAddress = getClientIp(request);
        String userAgent = request != null ? request.getHeader("User-Agent") : null;

        AuditLog auditLog = AuditLog.builder()
                .actionType(actionType)
                .description(description)
                .username(username)
                .ipAddress(ipAddress)
                .userAgent(userAgent)
                .success(success)
                .resourceId(resourceId)
                .requestDetails(requestDetails)
                .timestamp(LocalDateTime.now())
                .build();

        try {
            auditLogRepository.save(auditLog);
            log.debug("Audit log saved: {} - {}", actionType, description);
        } catch (Exception e) {
            log.error("Failed to save audit log: {}", e.getMessage());
        }
    }

    public void logSecurityEvent(String actionType, String description, boolean success,
                                 HttpServletRequest request) {
        logActivity(actionType, description, success, null, null, request);
    }

    public void logTransferActivity(Long fromCardId, Long toCardId, BigDecimal amount,
                                    boolean success, String errorMessage, HttpServletRequest request) {
        String description = String.format("Transfer %.2f from card %d to card %d",
                amount, fromCardId, toCardId);
        String requestDetails = String.format("{\"fromCardId\": %d, \"toCardId\": %d, \"amount\": %.2f}",
                fromCardId, toCardId, amount);

        logActivity("TRANSFER", description, success, fromCardId.toString(),
                requestDetails, request);

        if (!success && errorMessage != null) {
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ª–æ–≥ –¥–ª—è –æ—à–∏–±–æ–∫
            logActivity("TRANSFER_ERROR", errorMessage, false, fromCardId.toString(),
                    requestDetails, request);
        }
    }

    private String getCurrentUsername() {
        try {
            return SecurityContextHolder.getContext().getAuthentication().getName();
        } catch (Exception e) {
            return "SYSTEM";
        }
    }

    private String getClientIp(HttpServletRequest request) {
        if (request == null) return "unknown";

        String xfHeader = request.getHeader("X-Forwarded-For");
        if (xfHeader != null) {
            return xfHeader.split(",")[0];
        }
        return request.getRemoteAddr();
    }
}


package com.bank.service;

import com.bank.entity.User;
import com.bank.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AuthService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));

        return user;
    }
}


package com.bank.service;

import com.bank.entity.Card;
import com.bank.entity.Transaction;
import com.bank.entity.User;
import com.bank.event.CardBlockRequestedEvent;
import com.bank.event.TransferCompletedEvent;
import com.bank.exception.*;
import com.bank.repository.CardRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class CardService {

    private final CardRepository cardRepository;
    private final EncryptionService encryptionService;
    private final TransactionService transactionService;
    private final MonitoringService monitoringService;
    private final ApplicationEventPublisher eventPublisher;
    private final AuditService auditService;

    public Page<Card> getUserCards(User user, Pageable pageable, String search) {
        log.debug("Getting cards for user: id={}, username={}", user.getId(), user.getUsername());

        if (search != null && !search.trim().isEmpty()) {
            return cardRepository.findByUserAndCardHolderContainingIgnoreCase(user, search.trim(), pageable);
        }

        return cardRepository.findByUser(user, pageable);
    }

    public List<Card> getUserActiveCards(User user) {
        return cardRepository.findActiveUserCards(user);
    }

    public Card getCardById(Long cardId, User user) {
        log.debug("Getting card {} for user: id={}, username={}", cardId, user.getId(), user.getUsername());

        Card card = cardRepository.findById(cardId)
                .orElseThrow(() -> new CardNotFoundException("Card not found with id: " + cardId));

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è –≤–ª–∞–¥–µ–ª—å—Ü–µ–º –∫–∞—Ä—Ç—ã –∏–ª–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º
        boolean isOwner = card.getUser().getId().equals(user.getId());
        boolean isAdmin = user.getRole().equals(User.Role.ROLE_ADMIN);

        log.debug("Card user id: {}, current user id: {}, isOwner: {}, isAdmin: {}",
                card.getUser().getId(), user.getId(), isOwner, isAdmin);

        if (!isOwner && !isAdmin) {
            throw new UnauthorizedAccessException("Access denied to card");
        }

        return card;
    }

    public Page<Card> getAllCards(Pageable pageable) {
        return cardRepository.findAll(pageable);
    }

    @Transactional
    public void deleteCard(Long cardId) {
        if (!cardRepository.existsById(cardId)) {
            throw new CardNotFoundException("Card not found with id: " + cardId);
        }
        cardRepository.deleteById(cardId);
        log.info("Card deleted successfully: {}", cardId);
    }

    @Transactional
    public Card createCard(Card card) {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç –∫–∞—Ä—Ç—ã
        if (cardRepository.existsByCardNumber(card.getCardNumber())) {
            throw new CardAlreadyExistsException("Card with this number already exists");
        }

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å
        if (card.getBalance() == null) {
            card.setBalance(BigDecimal.ZERO);
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è
        if (card.getExpiryDate().isBefore(LocalDate.now())) {
            card.setStatus(Card.CardStatus.EXPIRED);
        } else {
            card.setStatus(Card.CardStatus.ACTIVE);
        }

        Card savedCard = cardRepository.save(card);
        log.info("Card created successfully: {} for user {}", savedCard.getId(),
                card.getUser().getUsername());

        // –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã
        auditService.logActivity("CARD_CREATE",
                String.format("Card created: %s for user %s", savedCard.getId(), card.getUser().getUsername()),
                true, savedCard.getId().toString(), null, null);

        return savedCard;
    }

    @Transactional
    public Card updateCardStatus(Long cardId, Card.CardStatus status) {
        Card card = cardRepository.findById(cardId)
                .orElseThrow(() -> new CardNotFoundException("Card not found with id: " + cardId));

        card.setStatus(status);
        Card updatedCard = cardRepository.save(card);

        // –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
        auditService.logActivity("CARD_STATUS_UPDATE",
                String.format("Card status updated to %s", status),
                true, cardId.toString(), null, null);

        log.info("Card status updated: {} -> {}", cardId, status);
        return updatedCard;
    }

    @Transactional
    public void requestCardBlock(Long cardId, User user) {
        Card card = getCardById(cardId, user);
        card.setBlockRequested(true);
        cardRepository.save(card);

        // –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ –∑–∞–ø—Ä–æ—Å–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
        eventPublisher.publishEvent(new CardBlockRequestedEvent(this, card, "User requested block"));

        monitoringService.recordCardBlockRequest(cardId, user.getUsername());

        // –õ–æ–≥–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
        auditService.logActivity("CARD_BLOCK_REQUEST",
                String.format("Block requested for card %s", cardId),
                true, cardId.toString(), null, null);

        log.info("Block requested for card: {} by user: {}", cardId, user.getUsername());
    }

    public List<Card> getCardsWithBlockRequests() {
        return cardRepository.findByBlockRequestedTrue();
    }

    @Transactional
    public void transferBetweenCards(User user, Long fromCardId, Long toCardId, BigDecimal amount) {
        long startTime = System.currentTimeMillis();

        try {
            if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                throw new IllegalArgumentException("Transfer amount must be positive");
            }

            if (fromCardId.equals(toCardId)) {
                throw new IllegalArgumentException("Cannot transfer to the same card");
            }

            Card fromCard = getCardById(fromCardId, user);
            Card toCard = getCardById(toCardId, user);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±–µ –∫–∞—Ä—Ç—ã –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            if (!fromCard.getUser().getId().equals(user.getId()) ||
                    !toCard.getUser().getId().equals(user.getId())) {
                throw new UnauthorizedAccessException("You can only transfer between your own cards");
            }

            if (!fromCard.isActive()) {
                throw new IllegalStateException("Source card is not active");
            }

            if (!toCard.isActive()) {
                throw new IllegalStateException("Destination card is not active");
            }

            if (fromCard.getBalance().compareTo(amount) < 0) {
                throw new InsufficientBalanceException("Insufficient balance for transfer");
            }

            // –í—ã–ø–æ–ª–Ω—è–µ–º –ø–µ—Ä–µ–≤–æ–¥
            fromCard.setBalance(fromCard.getBalance().subtract(amount));
            toCard.setBalance(toCard.getBalance().add(amount));

            cardRepository.save(fromCard);
            cardRepository.save(toCard);

            // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            Transaction transaction = Transaction.builder()
                    .fromCard(fromCard)
                    .toCard(toCard)
                    .amount(amount)
                    .status(Transaction.TransactionStatus.SUCCESS)
                    .build();

            Transaction savedTransaction = transactionService.saveTransaction(transaction);

            // –ü—É–±–ª–∏–∫—É–µ–º —Å–æ–±—ã—Ç–∏–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–µ—Ä–µ–≤–æ–¥–∞
            eventPublisher.publishEvent(new TransferCompletedEvent(this, savedTransaction, fromCard, toCard, amount));

            long duration = System.currentTimeMillis() - startTime;
            monitoringService.recordTransfer(user.getUsername(), toCard.getUser().getUsername(), amount);

            // –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥
            auditService.logActivity("TRANSFER_SUCCESS",
                    String.format("Transfer %.2f from card %s to card %s", amount, fromCardId, toCardId),
                    true, fromCardId.toString(),
                    String.format("{\"fromCardId\": %d, \"toCardId\": %d, \"amount\": %.2f}", fromCardId, toCardId, amount),
                    null);

            log.info("Transfer completed: {} from card {} to card {} ({} ms)",
                    amount, fromCardId, toCardId, duration);

        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;

            // –õ–æ–≥–∏—Ä—É–µ–º –Ω–µ—É–¥–∞—á–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥
            auditService.logActivity("TRANSFER_FAILED",
                    String.format("Transfer failed: %.2f from card %s to card %s - %s", amount, fromCardId, toCardId, e.getMessage()),
                    false, fromCardId.toString(),
                    String.format("{\"fromCardId\": %d, \"toCardId\": %d, \"amount\": %.2f}", fromCardId, toCardId, amount),
                    null);

            log.error("Transfer failed: {} from card {} to card {} ({} ms) - Error: {}",
                    amount, fromCardId, toCardId, duration, e.getMessage());
            throw e;
        }
    }

    public String getMaskedCardNumber(String encryptedCardNumber) {
        try {
            String decrypted = encryptionService.decrypt(encryptedCardNumber);
            if (decrypted != null && decrypted.length() >= 4) {
                return "**** **** **** " + decrypted.substring(decrypted.length() - 4);
            }
            return "**** **** **** ****";
        } catch (Exception e) {
            log.warn("Error decrypting card number for masking: {}", e.getMessage());
            return "**** **** **** ****";
        }
    }

    @Scheduled(cron = "0 0 0 * * ?")
    @Transactional
    public void checkAndUpdateExpiredCards() {
        List<Card> expiredCards = cardRepository.findByStatusAndExpiryDateBefore(
                Card.CardStatus.ACTIVE, LocalDate.now());

        for (Card card : expiredCards) {
            card.setStatus(Card.CardStatus.EXPIRED);
            log.info("Card {} expired and was deactivated", card.getId());

            // –õ–æ–≥–∏—Ä—É–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å—Ç–µ—á–µ–Ω–∏–µ —Å—Ä–æ–∫–∞
            auditService.logActivity("CARD_EXPIRED_AUTO",
                    String.format("Card %s expired automatically", card.getId()),
                    true, card.getId().toString(), null, null);
        }

        if (!expiredCards.isEmpty()) {
            cardRepository.saveAll(expiredCards);
        }
    }

    public boolean isCardOwnedByUser(Long cardId, User user) {
        return cardRepository.findByIdAndUser(cardId, user).isPresent();
    }
}


package com.bank.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

@Service
public class EncryptionService {

    private final String encryptionKey;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥–ª—è —Ç–µ—Å—Ç–æ–≤
    public EncryptionService() {
        this.encryptionKey = "test-encryption-key-32-chars-long!";
    }

    public EncryptionService(@Value("${app.encryption.key:bank-encryption-key-32-chars-long!}") String encryptionKey) {
        this.encryptionKey = encryptionKey;
    }

    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/ECB/PKCS5Padding";

    private SecretKeySpec getSecretKey() {
        // –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º –∫–ª—é—á –¥–ª–∏–Ω–æ–π 16, 24 –∏–ª–∏ 32 –±–∞–π—Ç–∞
        byte[] keyBytes = new byte[32];
        byte[] originalBytes = encryptionKey.getBytes();
        System.arraycopy(originalBytes, 0, keyBytes, 0, Math.min(originalBytes.length, keyBytes.length));
        return new SecretKeySpec(keyBytes, ALGORITHM);
    }

    public String encrypt(String data) {
        try {
            if (data == null) return null;

            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE, getSecretKey());
            byte[] encryptedBytes = cipher.doFinal(data.getBytes());
            return Base64.getEncoder().encodeToString(encryptedBytes);
        } catch (Exception e) {
            throw new RuntimeException("Error encrypting data", e);
        }
    }

    public String decrypt(String encryptedData) {
        try {
            if (encryptedData == null) return null;

            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.DECRYPT_MODE, getSecretKey());
            byte[] decodedBytes = Base64.getDecoder().decode(encryptedData);
            byte[] decryptedBytes = cipher.doFinal(decodedBytes);
            return new String(decryptedBytes);
        } catch (Exception e) {
            throw new RuntimeException("Error decrypting data", e);
        }
    }
}


package com.bank.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

@Slf4j
@Service
public class MonitoringService {

    private final ConcurrentHashMap<String, AtomicLong> metrics = new ConcurrentHashMap<>();

    public MonitoringService() {
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç—Ä–∏–∫
        metrics.put("login.success", new AtomicLong(0));
        metrics.put("login.failure", new AtomicLong(0));
        metrics.put("transfer.completed", new AtomicLong(0));
        metrics.put("card.block.requests", new AtomicLong(0));
        metrics.put("api.requests", new AtomicLong(0));
    }

    public void recordSuccessfulLogin(String username) {
        metrics.get("login.success").incrementAndGet();
        log.info("‚úÖ Successful login for user: {}", username);
    }

    public void recordFailedLogin(String username) {
        metrics.get("login.failure").incrementAndGet();
        log.warn("‚ùå Failed login attempt for user: {}", username);
    }

    public void recordTransfer(String fromUser, String toUser, BigDecimal amount) {
        metrics.get("transfer.completed").incrementAndGet();
        log.info("üí∞ Transfer completed: {} from {} to {}", amount, fromUser, toUser);
    }

    public void recordCardBlockRequest(Long cardId, String username) {
        metrics.get("card.block.requests").incrementAndGet();
        log.info("üö´ Card block requested: card {} by user {}", cardId, username);
    }

    public void recordApiRequest() {
        metrics.get("api.requests").incrementAndGet();
    }

    public long getMetric(String metricName) {
        AtomicLong metric = metrics.get(metricName);
        return metric != null ? metric.get() : 0;
    }

    public ConcurrentHashMap<String, AtomicLong> getAllMetrics() {
        return new ConcurrentHashMap<>(metrics);
    }

    public void recordSystemHealth() {
        long usedMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        long maxMemory = Runtime.getRuntime().maxMemory();
        double memoryUsage = (double) usedMemory / maxMemory * 100;

        log.debug("üíæ Memory usage: {}/{} MB ({:.2f}%)",
                usedMemory / (1024 * 1024),
                maxMemory / (1024 * 1024),
                memoryUsage);
    }
}



package com.bank.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.regex.Pattern;

@Slf4j
@Service
public class PasswordPolicyService {

    private static final int MIN_PASSWORD_LENGTH = 8;
    private static final int MAX_PASSWORD_LENGTH = 128;
    private static final Pattern UPPERCASE_PATTERN = Pattern.compile("[A-Z]");
    private static final Pattern LOWERCASE_PATTERN = Pattern.compile("[a-z]");
    private static final Pattern DIGIT_PATTERN = Pattern.compile("[0-9]");
    private static final Pattern SPECIAL_CHAR_PATTERN = Pattern.compile("[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]");

    // –£–±–∏—Ä–∞–µ–º –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ Spring-–∏–Ω—ä–µ–∫—Ü–∏—é
    public PasswordPolicyService() {
        // –ü—É—Å—Ç–æ–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥–ª—è Spring
    }

    public boolean validatePassword(String password) {
        if (password == null) {
            log.warn("Password is null");
            return false;
        }

        if (password.length() < MIN_PASSWORD_LENGTH || password.length() > MAX_PASSWORD_LENGTH) {
            log.warn("Password length invalid: {} (must be between {} and {})",
                    password.length(), MIN_PASSWORD_LENGTH, MAX_PASSWORD_LENGTH);
            return false;
        }

        // –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è - –°–¢–†–û–ì–ê–Ø –í–ê–õ–ò–î–ê–¶–ò–Ø
        boolean hasUppercase = UPPERCASE_PATTERN.matcher(password).find();
        boolean hasLowercase = LOWERCASE_PATTERN.matcher(password).find();
        boolean hasDigit = DIGIT_PATTERN.matcher(password).find();
        boolean hasSpecialChar = SPECIAL_CHAR_PATTERN.matcher(password).find();

        log.debug("Password validation - Uppercase: {}, Lowercase: {}, Digit: {}, Special: {}",
                hasUppercase, hasLowercase, hasDigit, hasSpecialChar);

        // –°–¢–†–û–ì–ò–ï –¢–†–ï–ë–û–í–ê–ù–ò–Ø: –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤–µ—Ä—Ö–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä + –º–∏–Ω–∏–º—É–º 2 –¥—Ä—É–≥–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        if (!hasUppercase) {
            log.warn("Password must contain at least one uppercase letter");
            return false;
        }

        int additionalRequirementsMet = 0;
        if (hasLowercase) additionalRequirementsMet++;
        if (hasDigit) additionalRequirementsMet++;
        if (hasSpecialChar) additionalRequirementsMet++;

        // –¢—Ä–µ–±—É–µ–º –∫–∞–∫ –º–∏–Ω–∏–º—É–º 2 –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        boolean isValid = additionalRequirementsMet >= 2;

        if (!isValid) {
            log.warn("Password complexity requirements not met. Required: uppercase + 2 additional categories, Actual additional: {}", additionalRequirementsMet);
        }

        return isValid;
    }

    public String generatePasswordRequirementsMessage() {
        return String.format(
                "Password must be between %d and %d characters long and contain: at least one uppercase letter, and at least two of the following: lowercase letters, numbers, special characters",
                MIN_PASSWORD_LENGTH, MAX_PASSWORD_LENGTH
        );
    }
}


package com.bank.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
@Service
@RequiredArgsConstructor
public class RateLimitService {

    private final CacheManager cacheManager;

    private static final int MAX_REQUESTS_PER_MINUTE = 100;
    private static final int MAX_LOGIN_ATTEMPTS_PER_HOUR = 5;
    private static final int MAX_TRANSFERS_PER_DAY = 10;

    public boolean isRateLimited(String key, RateLimitType type) {
        String cacheKey = type + "_" + key;
        Cache cache = cacheManager.getCache("rateLimit");

        RateLimitInfo rateLimitInfo = cache.get(cacheKey, RateLimitInfo.class);
        if (rateLimitInfo == null) {
            rateLimitInfo = new RateLimitInfo();
            cache.put(cacheKey, rateLimitInfo);
        }

        return rateLimitInfo.isRateLimited(type);
    }

    public void recordRequest(String key, RateLimitType type) {
        String cacheKey = type + "_" + key;
        Cache cache = cacheManager.getCache("rateLimit");

        RateLimitInfo rateLimitInfo = cache.get(cacheKey, RateLimitInfo.class);
        if (rateLimitInfo == null) {
            rateLimitInfo = new RateLimitInfo();
        }

        rateLimitInfo.recordRequest(type);
        cache.put(cacheKey, rateLimitInfo);
    }

    public enum RateLimitType {
        API_REQUEST,
        LOGIN_ATTEMPT,
        TRANSFER_OPERATION
    }

    private static class RateLimitInfo {
        private final AtomicInteger requestsLastMinute = new AtomicInteger(0);
        private final AtomicInteger loginAttemptsLastHour = new AtomicInteger(0);
        private final AtomicInteger transfersLastDay = new AtomicInteger(0);
        private LocalDateTime minuteWindowStart = LocalDateTime.now();
        private LocalDateTime hourWindowStart = LocalDateTime.now();
        private LocalDateTime dayWindowStart = LocalDateTime.now();

        public synchronized boolean isRateLimited(RateLimitType type) {
            resetCountersIfNeeded();

            switch (type) {
                case API_REQUEST:
                    return requestsLastMinute.get() >= MAX_REQUESTS_PER_MINUTE;
                case LOGIN_ATTEMPT:
                    return loginAttemptsLastHour.get() >= MAX_LOGIN_ATTEMPTS_PER_HOUR;
                case TRANSFER_OPERATION:
                    return transfersLastDay.get() >= MAX_TRANSFERS_PER_DAY;
                default:
                    return false;
            }
        }

        public synchronized void recordRequest(RateLimitType type) {
            resetCountersIfNeeded();

            switch (type) {
                case API_REQUEST:
                    requestsLastMinute.incrementAndGet();
                    break;
                case LOGIN_ATTEMPT:
                    loginAttemptsLastHour.incrementAndGet();
                    break;
                case TRANSFER_OPERATION:
                    transfersLastDay.incrementAndGet();
                    break;
            }
        }

        private void resetCountersIfNeeded() {
            LocalDateTime now = LocalDateTime.now();

            if (now.minusMinutes(1).isAfter(minuteWindowStart)) {
                requestsLastMinute.set(0);
                minuteWindowStart = now;
            }

            if (now.minusHours(1).isAfter(hourWindowStart)) {
                loginAttemptsLastHour.set(0);
                hourWindowStart = now;
            }

            if (now.minusDays(1).isAfter(dayWindowStart)) {
                transfersLastDay.set(0);
                dayWindowStart = now;
            }
        }
    }
}


package com.bank.service;

import com.bank.entity.Transaction;
import com.bank.repository.TransactionRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Service
@RequiredArgsConstructor
public class TransactionReportService {

    private final TransactionRepository transactionRepository;

    public Map<String, Object> getDailyTransactionReport() {
        LocalDateTime startOfDay = LocalDateTime.now().withHour(0).withMinute(0).withSecond(0);
        LocalDateTime endOfDay = LocalDateTime.now().withHour(23).withMinute(59).withSecond(59);

        long totalTransactions = transactionRepository.countByTransactionDateBetween(startOfDay, endOfDay);
        BigDecimal totalAmount = transactionRepository.sumAmountByTransactionDateBetween(startOfDay, endOfDay);
        long successfulTransactions = transactionRepository.countByStatusAndTransactionDateBetween(
                Transaction.TransactionStatus.SUCCESS, startOfDay, endOfDay);

        Map<String, Object> report = new HashMap<>();
        report.put("date", LocalDateTime.now().toLocalDate());
        report.put("totalTransactions", totalTransactions);
        report.put("successfulTransactions", successfulTransactions);
        report.put("failedTransactions", totalTransactions - successfulTransactions);
        report.put("totalAmount", totalAmount != null ? totalAmount : BigDecimal.ZERO);
        report.put("successRate", totalTransactions > 0 ?
                BigDecimal.valueOf((double) successfulTransactions / totalTransactions * 100)
                        .setScale(2, RoundingMode.HALF_UP) : BigDecimal.ZERO);

        return report;
    }

    public Map<String, Object> getUserTransactionStats(Long userId) {
        LocalDateTime last30Days = LocalDateTime.now().minusDays(30);

        long userTransactions = transactionRepository.countByUserInLast30Days(userId, last30Days);
        BigDecimal userTotalAmount = transactionRepository.sumAmountByUserInLast30Days(userId, last30Days);

        Map<String, Object> stats = new HashMap<>();
        stats.put("userId", userId);
        stats.put("period", "LAST_30_DAYS");
        stats.put("totalTransactions", userTransactions);
        stats.put("totalAmount", userTotalAmount != null ? userTotalAmount : BigDecimal.ZERO);
        stats.put("averageAmount", userTransactions > 0 ?
                userTotalAmount.divide(BigDecimal.valueOf(userTransactions), 2, RoundingMode.HALF_UP) : BigDecimal.ZERO);

        return stats;
    }
}


package com.bank.service;

import com.bank.entity.Transaction;
import com.bank.repository.TransactionRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class TransactionService {

    private final TransactionRepository transactionRepository;

    public Transaction saveTransaction(Transaction transaction) {
        return transactionRepository.save(transaction);
    }
}


package com.bank.service;

import com.bank.entity.User;
import com.bank.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    public User getUserById(Long userId) {
        return userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with id: " + userId));
    }

    public User getUserByUsername(String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
    }

    public Page<User> getAllUsers(Pageable pageable) {
        return userRepository.findAll(pageable);
    }

    public boolean userExists(Long userId) {
        return userRepository.existsById(userId);
    }
}


package com.bank.validation;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import java.lang.annotation.*;

@Documented
@Constraint(validatedBy = StrongPasswordValidator.class)
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface StrongPassword {
    String message() default "Password does not meet security requirements";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}


package com.bank.validation;

import com.bank.service.PasswordPolicyService;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class StrongPasswordValidator implements ConstraintValidator<StrongPassword, String> {

    private final PasswordPolicyService passwordPolicyService;

    @Override
    public boolean isValid(String password, ConstraintValidatorContext context) {
        if (password == null) {
            return false;
        }
        return passwordPolicyService.validatePassword(password);
    }
}


package com.bank;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BankApplication {
    public static void main(String[] args) {
        SpringApplication.run(BankApplication.class, args);
    }
}


/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import java.io.IOException;
import java.io.InputStream;
import java.net.Authenticator;
import java.net.PasswordAuthentication;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

public final class MavenWrapperDownloader {

    private static final String WRAPPER_VERSION = "3.2.0";
    /**
     * Default URL to download the maven-wrapper.jar from, if no 'downloadUrl' is provided.
     */
    private static final String DEFAULT_DOWNLOAD_URL = "https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/"
            + WRAPPER_VERSION + "/maven-wrapper-" + WRAPPER_VERSION + ".jar";

    /**
     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to
     * use instead of the default one.
     */
    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =
            ".mvn/wrapper/maven-wrapper.properties";

    /**
     * Path where the maven-wrapper.jar will be saved to.
     */
    private static final String MAVEN_WRAPPER_JAR_PATH =
            ".mvn/wrapper/maven-wrapper.jar";

    /**
     * Name of the property which should be used to override the default download url for the wrapper.
     */
    private static final String PROPERTY_NAME_WRAPPER_URL = "wrapperUrl";

    public static void main(String[] args) {
        System.out.println("- Downloader started");
        Path baseDirectory = Paths.get(args[0]);
        try {
            System.out.println("- Using base directory: " + baseDirectory.toAbsolutePath());

            // If the maven-wrapper.properties exists, read it and check if it contains a custom
            // wrapperUrl parameter.
            Path mavenWrapperPropertyFile = baseDirectory.resolve(MAVEN_WRAPPER_PROPERTIES_PATH);
            String url = DEFAULT_DOWNLOAD_URL;
            if (Files.exists(mavenWrapperPropertyFile)) {
                try (InputStream in = Files.newInputStream(mavenWrapperPropertyFile)) {
                    java.util.Properties p = new java.util.Properties();
                    p.load(in);
                    url = p.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
                }
            }
            System.out.println("- Downloading from: " + url);

            Path outputFile = baseDirectory.resolve(MAVEN_WRAPPER_JAR_PATH);
            // If a download is required, then create the authenticator, as the download may be from a protected repo
            if (url.startsWith("http") && System.getenv("MVNW_USERNAME") != null && System.getenv("MVNW_PASSWORD") != null) {
                String username = System.getenv("MVNW_USERNAME");
                char[] password = System.getenv("MVNW_PASSWORD").toCharArray();
                Authenticator.setDefault(new Authenticator() {
                    @Override
                    protected PasswordAuthentication getPasswordAuthentication() {
                        return new PasswordAuthentication(username, password);
                    }
                });
            }
            try (InputStream in = new URL(url).openStream()) {
                Files.copy(in, outputFile, StandardCopyOption.REPLACE_EXISTING);
            }
            System.out.println("Done");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}


<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.3.xsd">

    <include file="db/migration/001-create-users-table.xml" relativeToChangelogFile="true"/>
    <include file="db/migration/002-create-cards-table.xml" relativeToChangelogFile="true"/>
    <include file="db/migration/003-create-transactions-table.xml" relativeToChangelogFile="true"/>
</databaseChangeLog>


<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.3.xsd">

    <changeSet id="001-create-users-table" author="bank">
        <createTable tableName="users">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="username" type="VARCHAR(50)">
                <constraints unique="true" nullable="false"/>
            </column>
            <column name="password" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="email" type="VARCHAR(100)">
                <constraints unique="true" nullable="false"/>
            </column>
            <column name="role" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="created_at" type="TIMESTAMP" defaultValueComputed="CURRENT_TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>

        <createIndex tableName="users" indexName="idx_users_username">
            <column name="username"/>
        </createIndex>

        <createIndex tableName="users" indexName="idx_users_email">
            <column name="email"/>
        </createIndex>
    </changeSet>
</databaseChangeLog>


<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.3.xsd">

    <changeSet id="002-create-cards-table" author="bank">
        <createTable tableName="cards">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="card_number" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="card_holder" type="VARCHAR(100)">
                <constraints nullable="false"/>
            </column>
            <column name="expiry_date" type="DATE">
                <constraints nullable="false"/>
            </column>
            <column name="balance" type="DECIMAL(15,2)" defaultValue="0.00">
                <constraints nullable="false"/>
            </column>
            <column name="status" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
            <column name="user_id" type="BIGINT">
                <constraints nullable="false" foreignKeyName="fk_cards_user_id" references="users(id)"/>
            </column>
            <column name="created_at" type="TIMESTAMP" defaultValueComputed="CURRENT_TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>

        <createIndex tableName="cards" indexName="idx_cards_user_id">
            <column name="user_id"/>
        </createIndex>

        <createIndex tableName="cards" indexName="idx_cards_status">
            <column name="status"/>
        </createIndex>

        <createIndex tableName="cards" indexName="idx_cards_expiry_date">
            <column name="expiry_date"/>
        </createIndex>
    </changeSet>
</databaseChangeLog>


<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.3.xsd">

    <changeSet id="003-create-transactions-table" author="bank">
        <createTable tableName="transactions">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="from_card_id" type="BIGINT">
                <constraints nullable="true" foreignKeyName="fk_transactions_from_card" references="cards(id)"/>
            </column>
            <column name="to_card_id" type="BIGINT">
                <constraints nullable="false" foreignKeyName="fk_transactions_to_card" references="cards(id)"/>
            </column>
            <column name="amount" type="DECIMAL(15,2)">
                <constraints nullable="false"/>
            </column>
            <column name="transaction_date" type="TIMESTAMP" defaultValueComputed="CURRENT_TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="status" type="VARCHAR(20)">
                <constraints nullable="false"/>
            </column>
        </createTable>

        <createIndex tableName="transactions" indexName="idx_transactions_from_card">
            <column name="from_card_id"/>
        </createIndex>

        <createIndex tableName="transactions" indexName="idx_transactions_to_card">
            <column name="to_card_id"/>
        </createIndex>

        <createIndex tableName="transactions" indexName="idx_transactions_date">
            <column name="transaction_date"/>
        </createIndex>
    </changeSet>
</databaseChangeLog>


<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.3.xsd">

    <changeSet id="004-create-audit-logs-table" author="bank">
        <createTable tableName="audit_logs">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true" nullable="false"/>
            </column>
            <column name="action_type" type="VARCHAR(50)">
                <constraints nullable="false"/>
            </column>
            <column name="description" type="VARCHAR(500)">
                <constraints nullable="false"/>
            </column>
            <column name="username" type="VARCHAR(100)">
                <constraints nullable="false"/>
            </column>
            <column name="ip_address" type="VARCHAR(45)"/>
            <column name="user_agent" type="VARCHAR(500)"/>
            <column name="success" type="BOOLEAN">
                <constraints nullable="false"/>
            </column>
            <column name="error_message" type="VARCHAR(1000)"/>
            <column name="timestamp" type="TIMESTAMP" defaultValueComputed="CURRENT_TIMESTAMP">
                <constraints nullable="false"/>
            </column>
            <column name="resource_id" type="VARCHAR(50)"/>
            <column name="request_details" type="VARCHAR(1000)"/>
        </createTable>

        <createIndex tableName="audit_logs" indexName="idx_audit_username">
            <column name="username"/>
        </createIndex>

        <createIndex tableName="audit_logs" indexName="idx_audit_action_type">
            <column name="action_type"/>
        </createIndex>

        <createIndex tableName="audit_logs" indexName="idx_audit_timestamp">
            <column name="timestamp"/>
        </createIndex>

        <createIndex tableName="audit_logs" indexName="idx_audit_success">
            <column name="success"/>
        </createIndex>
    </changeSet>
</databaseChangeLog>


<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.3.xsd">

    <include file="db/migration/001-create-users-table.xml" relativeToChangelogFile="true"/>
    <include file="db/migration/002-create-cards-table.xml" relativeToChangelogFile="true"/>
    <include file="db/migration/003-create-transactions-table.xml" relativeToChangelogFile="true"/>
    <include file="db/migration/004-create-audit-logs-table.xml" relativeToChangelogFile="true"/>
</databaseChangeLog>


spring:
  application:
    name: bank-rest
  profiles:
    active: local
  jackson:
    serialization:
      write-dates-as-timestamps: false
      indent-output: true
    deserialization:
      fail-on-unknown-properties: false
    default-property-inclusion: non_null

server:
  port: 8080
  servlet:
    context-path: /

logging:
  level:
    com.bank: INFO
    org.springframework.security: INFO
    org.hibernate.SQL: DEBUG

---
spring:
  config:
    activate:
      on-profile: dev
  datasource:
    url: jdbc:postgresql://localhost:5432/bankdb
    username: bankuser
    password: bankpass
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect
  liquibase:
    enabled: true
    change-log: classpath:db/changelog/db.changelog-master.xml

jwt:
  secret: bank-rest-secret-key-2024-very-secure-and-long
  expiration: 86400000

app:
  encryption:
    key: bank-encryption-key-32-chars-long!

---
spring:
  config:
    activate:
      on-profile: local
  datasource:
    url: jdbc:h2:mem:bankdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: ''
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        show_sql: true
  h2:
    console:
      enabled: true
      path: /h2-console
  liquibase:
    enabled: false

jwt:
  secret: local-secret-key-for-development-very-long-secret-key
  expiration: 86400000

app:
  encryption:
    key: local-encryption-key-32-chars-long!

---
spring:
  config:
    activate:
      on-profile: test
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: ''
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: false
        show_sql: false
  liquibase:
    enabled: false
  h2:
    console:
      enabled: false

jwt:
  secret: test-secret-key-very-long-secret-key-for-testing-purposes-here
  expiration: 86400000

app:
  encryption:
    key: test-encryption-key-32-chars-long!

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
    enabled-by-default: false
  endpoint:
    health:
      enabled: true
      show-details: when-authorized
      show-components: when-authorized
    metrics:
      enabled: true
    info:
      enabled: true

springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui.html
    operations-sorter: method
    tags-sorter: alpha


spring:
  datasource:
    url: jdbc:h2:mem:bankdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password:
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.H2Dialect
  liquibase:
    enabled: false
  h2:
    console:
      enabled: true
      path: /h2-console

jwt:
  secret: bank-rest-secret-key-2024-very-secure-and-long
  expiration: 86400000

app:
  encryption:
    key: bank-encryption-key-32-chars-long!

logging:
  level:
    com.bank: DEBUG


spring:
  config:
    activate:
      on-profile: local
  datasource:
    url: jdbc:h2:mem:bankdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password:
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop  # –ò—Å–ø–æ–ª—å–∑—É–µ–º create-drop –¥–ª—è –ø–æ–ª–Ω–æ–π –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        show_sql: true
    defer-datasource-initialization: true
  sql:
    init:
      mode: never
  liquibase:
    enabled: false
  h2:
    console:
      enabled: true
      path: /h2-console

jwt:
  secret: local-secret-key-for-development
  expiration: 86400000

app:
  encryption:
    key: local-encryption-key-32-chars-long!


logging:
  level:
    com.bank: INFO
    com.bank.monitoring: DEBUG
    org.springframework.security: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/bank-app.log
  logback:
    rollingpolicy:
      max-file-size: 10MB
      max-history: 30

management:
  endpoints:
    web:
      exposure:
        include: health,metrics,auditevents
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true


spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password:
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: false
        show_sql: false
  h2:
    console:
      enabled: false
  security:
    oauth2:
      resourceserver:
        jwt:
          secret-value: test-secret

jwt:
  secret: test-secret-key-very-long-secret-key-for-testing-purposes-here
  expiration: 86400000

app:
  encryption:
    key: test-encryption-key-32-chars-long!

logging:
  level:
    com.bank: WARN
    org.springframework: WARN
    org.hibernate: WARN
    org.springframework.security: WARN


version: '3.8'

services:
  postgres:
    image: postgres:13-alpine
    container_name: bank-postgres
    environment:
      POSTGRES_DB: bankdb
      POSTGRES_USER: bankuser
      POSTGRES_PASSWORD: bankpass
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - bank-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U bankuser -d bankdb"]
      interval: 30s
      timeout: 10s
      retries: 3

  app:
    build: .
    container_name: bank-app
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: dev
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/bankdb
      SPRING_DATASOURCE_USERNAME: bankuser
      SPRING_DATASOURCE_PASSWORD: bankpass
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - bank-network
    restart: unless-stopped

volumes:
  postgres_data:

networks:
  bank-network:
    driver: bridge



package com.bank.security;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.Collections;

import static org.junit.jupiter.api.Assertions.*;

class JwtTokenProviderTest {

    private JwtTokenProvider jwtTokenProvider;

    @BeforeEach
    void setUp() {
        jwtTokenProvider = new JwtTokenProvider();
    }

    @Test
    void generateToken_ShouldCreateValidToken() {
        // Given
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                "testuser",
                "password",
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER"))
        );

        // When
        String token = jwtTokenProvider.generateToken(authentication);

        // Then
        assertNotNull(token);
        assertFalse(token.isEmpty());
    }

    @Test
    void getUsernameFromJWT_ShouldExtractUsername() {
        // Given
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                "testuser",
                "password",
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER"))
        );
        String token = jwtTokenProvider.generateToken(authentication);

        // When
        String username = jwtTokenProvider.getUsernameFromJWT(token);

        // Then
        assertEquals("testuser", username);
    }

    @Test
    void validateToken_ValidToken_ShouldReturnTrue() {
        // Given
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                "testuser",
                "password",
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER"))
        );
        String token = jwtTokenProvider.generateToken(authentication);

        // When
        boolean isValid = jwtTokenProvider.validateToken(token);

        // Then
        assertTrue(isValid);
    }

    @Test
    void validateToken_InvalidToken_ShouldReturnFalse() {
        // Given
        String invalidToken = "invalid.token.here";

        // When
        boolean isValid = jwtTokenProvider.validateToken(invalidToken);

        // Then
        assertFalse(isValid);
    }
}


package com.bank.service;

import com.bank.entity.User;
import com.bank.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AuthServiceTest {

    @Mock
    private UserRepository userRepository;

    private AuthService authService;

    @BeforeEach
    void setUp() {
        authService = new AuthService(userRepository);
    }

    @Test
    void loadUserByUsername_UserExists_ShouldReturnUserDetails() {
        // Given
        User user = User.builder()
                .id(1L)
                .username("testuser")
                .password("password")
                .email("test@bank.com")
                .role(User.Role.ROLE_USER)
                .build();

        when(userRepository.findByUsername("testuser")).thenReturn(Optional.of(user));

        // When
        UserDetails userDetails = authService.loadUserByUsername("testuser");

        // Then
        assertNotNull(userDetails);
        assertEquals("testuser", userDetails.getUsername());
        assertEquals("password", userDetails.getPassword());
        assertTrue(userDetails.getAuthorities().stream()
                .anyMatch(auth -> auth.getAuthority().equals("ROLE_USER")));
    }

    @Test
    void loadUserByUsername_UserNotFound_ShouldThrowException() {
        // Given
        when(userRepository.findByUsername("nonexistent")).thenReturn(Optional.empty());

        // When & Then
        assertThrows(UsernameNotFoundException.class,
                () -> authService.loadUserByUsername("nonexistent"));
    }
}


package com.bank.service;

import com.bank.entity.Card;
import com.bank.entity.User;
import com.bank.exception.CardNotFoundException;
import com.bank.exception.UnauthorizedAccessException;
import com.bank.repository.CardRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.context.ApplicationEventPublisher;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CardServiceTest {

    @Mock
    private CardRepository cardRepository;

    @Mock
    private EncryptionService encryptionService;

    @Mock
    private TransactionService transactionService;

    @Mock
    private MonitoringService monitoringService;

    @Mock
    private ApplicationEventPublisher eventPublisher;

    @Mock
    private AuditService auditService;

    private CardService cardService;

    private User testUser;
    private User adminUser;
    private Card testCard;

    @BeforeEach
    void setUp() {
        cardService = new CardService(
                cardRepository,
                encryptionService,
                transactionService,
                monitoringService,
                eventPublisher,
                auditService
        );

        testUser = new User();
        testUser.setId(1L);
        testUser.setUsername("testuser");
        testUser.setRole(User.Role.ROLE_USER);

        adminUser = new User();
        adminUser.setId(2L);
        adminUser.setUsername("admin");
        adminUser.setRole(User.Role.ROLE_ADMIN);

        testCard = new Card();
        testCard.setId(1L);
        testCard.setCardNumber("encrypted1234567890123456");
        testCard.setCardHolder("TEST USER");
        testCard.setExpiryDate(LocalDate.now().plusYears(2));
        testCard.setBalance(new BigDecimal("1000.00"));
        testCard.setStatus(Card.CardStatus.ACTIVE);
        testCard.setUser(testUser);
    }

    @Test
    void getCardById_UserOwnsCard_ShouldReturnCard() {
        // Given
        when(cardRepository.findById(1L)).thenReturn(Optional.of(testCard));

        // When
        Card result = cardService.getCardById(1L, testUser);

        // Then
        assertNotNull(result);
        assertEquals(testCard.getId(), result.getId());
        verify(cardRepository).findById(1L);
    }

    @Test
    void getCardById_AdminAccess_ShouldReturnCard() {
        // Given
        when(cardRepository.findById(1L)).thenReturn(Optional.of(testCard));

        // When
        Card result = cardService.getCardById(1L, adminUser);

        // Then
        assertNotNull(result);
        assertEquals(testCard.getId(), result.getId());
    }

    @Test
    void getCardById_UserNotOwner_ShouldThrowException() {
        // Given
        User otherUser = new User();
        otherUser.setId(3L);
        otherUser.setUsername("other");
        otherUser.setRole(User.Role.ROLE_USER);

        when(cardRepository.findById(1L)).thenReturn(Optional.of(testCard));

        // When & Then
        assertThrows(UnauthorizedAccessException.class,
                () -> cardService.getCardById(1L, otherUser));
    }

    @Test
    void getCardById_CardNotFound_ShouldThrowException() {
        // Given
        when(cardRepository.findById(1L)).thenReturn(Optional.empty());

        // When & Then
        assertThrows(CardNotFoundException.class,
                () -> cardService.getCardById(1L, testUser));
    }

    @Test
    void getMaskedCardNumber_ShouldReturnMaskedNumber() {
        // Given
        when(encryptionService.decrypt("encrypted1234567890123456")).thenReturn("1234567890123456");

        // When
        String masked = cardService.getMaskedCardNumber("encrypted1234567890123456");

        // Then
        assertEquals("**** **** **** 3456", masked);
    }

    @Test
    void getMaskedCardNumber_DecryptionFails_ShouldReturnDefault() {
        // Given
        when(encryptionService.decrypt("invalid")).thenThrow(new RuntimeException("Decryption failed"));

        // When
        String masked = cardService.getMaskedCardNumber("invalid");

        // Then
        assertEquals("**** **** **** ****", masked);
    }

    @Test
    void requestCardBlock_ShouldSetBlockRequestedFlag() {
        // Given
        when(cardRepository.findById(1L)).thenReturn(Optional.of(testCard));
        when(cardRepository.save(any(Card.class))).thenReturn(testCard);

        // When
        cardService.requestCardBlock(1L, testUser);

        // Then
        assertTrue(testCard.getBlockRequested());
        verify(cardRepository).save(testCard);
        verify(monitoringService).recordCardBlockRequest(1L, "testuser");
    }

    @Test
    void isCardOwnedByUser_CardExistsAndOwned_ShouldReturnTrue() {
        // Given
        when(cardRepository.findByIdAndUser(1L, testUser)).thenReturn(Optional.of(testCard));

        // When
        boolean result = cardService.isCardOwnedByUser(1L, testUser);

        // Then
        assertTrue(result);
    }

    @Test
    void isCardOwnedByUser_CardNotOwned_ShouldReturnFalse() {
        // Given
        when(cardRepository.findByIdAndUser(1L, testUser)).thenReturn(Optional.empty());

        // When
        boolean result = cardService.isCardOwnedByUser(1L, testUser);

        // Then
        assertFalse(result);
    }
}


package com.bank.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class EncryptionServiceTest {

    private EncryptionService encryptionService;

    @BeforeEach
    void setUp() {
        encryptionService = new EncryptionService();
    }

    @Test
    void encryptAndDecrypt_ShouldWorkCorrectly() {
        // Given
        String originalText = "1234567890123456";

        // When
        String encrypted = encryptionService.encrypt(originalText);
        String decrypted = encryptionService.decrypt(encrypted);

        // Then
        assertNotNull(encrypted);
        assertNotNull(decrypted);
        assertEquals(originalText, decrypted);
        assertNotEquals(originalText, encrypted);
    }

    @Test
    void encrypt_NullInput_ShouldReturnNull() {
        // When
        String result = encryptionService.encrypt(null);

        // Then
        assertNull(result);
    }

    @Test
    void decrypt_NullInput_ShouldReturnNull() {
        // When
        String result = encryptionService.decrypt(null);

        // Then
        assertNull(result);
    }

    @Test
    void encrypt_EmptyString_ShouldWork() {
        // Given
        String originalText = "";

        // When
        String encrypted = encryptionService.encrypt(originalText);
        String decrypted = encryptionService.decrypt(encrypted);

        // Then
        assertEquals(originalText, decrypted);
    }
}


package com.bank.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class PasswordPolicyServiceTest {

    private PasswordPolicyService passwordPolicyService;

    @BeforeEach
    void setUp() {
        passwordPolicyService = new PasswordPolicyService();
    }

    @Test
    void validatePassword_StrongPassword_ShouldReturnTrue() {
        // Given
        String strongPassword = "StrongPass123!"; // –í—Å–µ 4 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏

        // When
        boolean isValid = passwordPolicyService.validatePassword(strongPassword);

        // Then
        assertTrue(isValid, "Strong password with all categories should be valid");
    }

    @Test
    void validatePassword_TooShort_ShouldReturnFalse() {
        // Given
        String shortPassword = "Short1!"; // 7 —Å–∏–º–≤–æ–ª–æ–≤

        // When
        boolean isValid = passwordPolicyService.validatePassword(shortPassword);

        // Then
        assertFalse(isValid, "Password shorter than 8 characters should be invalid");
    }

    @Test
    void validatePassword_NullPassword_ShouldReturnFalse() {
        // When
        boolean isValid = passwordPolicyService.validatePassword(null);

        // Then
        assertFalse(isValid, "Null password should be invalid");
    }

    @Test
    void validatePassword_NoUppercase_ShouldReturnFalse() {
        // Given
        String noUppercase = "lowercase123!"; // –ù–µ—Ç –≤–µ—Ä—Ö–Ω–µ–≥–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞

        // When
        boolean isValid = passwordPolicyService.validatePassword(noUppercase);

        // Then
        assertFalse(isValid, "Password without uppercase should be invalid");
    }

    @Test
    void validatePassword_OnlyUppercase_ShouldReturnFalse() {
        // Given
        String onlyUppercase = "UPPERCASE"; // –¢–æ–ª—å–∫–æ –≤–µ—Ä—Ö–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä

        // When
        boolean isValid = passwordPolicyService.validatePassword(onlyUppercase);

        // Then
        assertFalse(isValid, "Password with only uppercase should be invalid (needs 2 additional categories)");
    }

    @Test
    void validatePassword_UpperCaseLowerCaseDigits_ShouldReturnTrue() {
        // Given
        String password = "Password123"; // –í–µ—Ä—Ö–Ω–∏–π + –Ω–∏–∂–Ω–∏–π + —Ü–∏—Ñ—Ä—ã (3 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏)

        // When
        boolean isValid = passwordPolicyService.validatePassword(password);

        // Then
        assertTrue(isValid, "Password with uppercase, lowercase and digits should be valid");
    }

    @Test
    void validatePassword_UpperCaseLowerCaseSpecial_ShouldReturnTrue() {
        // Given
        String password = "Password!"; // –í–µ—Ä—Ö–Ω–∏–π + –Ω–∏–∂–Ω–∏–π + —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª—ã (3 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏)

        // When
        boolean isValid = passwordPolicyService.validatePassword(password);

        // Then
        assertTrue(isValid, "Password with uppercase, lowercase and special chars should be valid");
    }

    @Test
    void validatePassword_UpperCaseDigitsSpecial_ShouldReturnTrue() {
        // Given
        String password = "PASSWORD123!"; // –í–µ—Ä—Ö–Ω–∏–π + —Ü–∏—Ñ—Ä—ã + —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª—ã (3 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏)

        // When
        boolean isValid = passwordPolicyService.validatePassword(password);

        // Then
        assertTrue(isValid, "Password with uppercase, digits and special chars should be valid");
    }

    @Test
    void validatePassword_UpperCaseLowerCaseOnly_ShouldReturnFalse() {
        // Given
        String password = "Password"; // –¢–æ–ª—å–∫–æ –≤–µ—Ä—Ö–Ω–∏–π + –Ω–∏–∂–Ω–∏–π (2 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏)

        // When
        boolean isValid = passwordPolicyService.validatePassword(password);

        // Then
        assertFalse(isValid, "Password with only uppercase and lowercase should be invalid (needs 3 categories total)");
    }

    @Test
    void validatePassword_UpperCaseDigitsOnly_ShouldReturnFalse() {
        // Given
        String password = "PASSWORD123"; // –¢–æ–ª—å–∫–æ –≤–µ—Ä—Ö–Ω–∏–π + —Ü–∏—Ñ—Ä—ã (2 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏)

        // When
        boolean isValid = passwordPolicyService.validatePassword(password);

        // Then
        assertFalse(isValid, "Password with only uppercase and digits should be invalid (needs 3 categories total)");
    }

    @Test
    void validatePassword_ValidComplexPassword_ShouldReturnTrue() {
        // Given
        String password = "MyPass123!"; // –í–µ—Ä—Ö–Ω–∏–π + –Ω–∏–∂–Ω–∏–π + —Ü–∏—Ñ—Ä—ã + —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª—ã

        // When
        boolean isValid = passwordPolicyService.validatePassword(password);

        // Then
        assertTrue(isValid, "Complex password should be valid");
    }
}


package com.bank.service;

import com.bank.entity.Transaction;
import com.bank.repository.TransactionRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class TransactionReportServiceTest {

    @Mock
    private TransactionRepository transactionRepository;

    private TransactionReportService transactionReportService;

    @BeforeEach
    void setUp() {
        transactionReportService = new TransactionReportService(transactionRepository);
    }

    @Test
    void getDailyTransactionReport_ShouldReturnReport() {
        // Given
        when(transactionRepository.countByTransactionDateBetween(any(), any())).thenReturn(10L);
        when(transactionRepository.sumAmountByTransactionDateBetween(any(), any())).thenReturn(new BigDecimal("1000.00"));
        when(transactionRepository.countByStatusAndTransactionDateBetween(any(), any(), any())).thenReturn(8L);

        // When
        Map<String, Object> report = transactionReportService.getDailyTransactionReport();

        // Then
        assertNotNull(report);
        assertEquals(10L, report.get("totalTransactions"));
        assertEquals(8L, report.get("successfulTransactions"));
        assertEquals(2L, report.get("failedTransactions"));
        assertEquals(new BigDecimal("1000.00"), report.get("totalAmount"));
    }

    @Test
    void getUserTransactionStats_ShouldReturnStats() {
        // Given
        when(transactionRepository.countByUserInLast30Days(any(), any())).thenReturn(5L);
        when(transactionRepository.sumAmountByUserInLast30Days(any(), any())).thenReturn(new BigDecimal("500.00"));

        // When
        Map<String, Object> stats = transactionReportService.getUserTransactionStats(1L);

        // Then
        assertNotNull(stats);
        assertEquals(1L, stats.get("userId"));
        assertEquals(5L, stats.get("totalTransactions"));
        assertEquals(new BigDecimal("500.00"), stats.get("totalAmount"));
        assertEquals(new BigDecimal("100.00"), stats.get("averageAmount"));
    }
}


package com.bank.service;

import com.bank.entity.User;
import com.bank.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    private UserService userService;

    @BeforeEach
    void setUp() {
        userService = new UserService(userRepository);
    }

    @Test
    void getUserById_UserExists_ShouldReturnUser() {
        // Given
        User user = new User();
        user.setId(1L);
        user.setUsername("testuser");

        when(userRepository.findById(1L)).thenReturn(Optional.of(user));

        // When
        User result = userService.getUserById(1L);

        // Then
        assertNotNull(result);
        assertEquals(1L, result.getId());
        assertEquals("testuser", result.getUsername());
    }

    @Test
    void getUserById_UserNotFound_ShouldThrowException() {
        // Given
        when(userRepository.findById(1L)).thenReturn(Optional.empty());

        // When & Then
        assertThrows(UsernameNotFoundException.class,
                () -> userService.getUserById(1L));
    }

    @Test
    void getUserByUsername_UserExists_ShouldReturnUser() {
        // Given
        User user = new User();
        user.setId(1L);
        user.setUsername("testuser");

        when(userRepository.findByUsername("testuser")).thenReturn(Optional.of(user));

        // When
        User result = userService.getUserByUsername("testuser");

        // Then
        assertNotNull(result);
        assertEquals(1L, result.getId());
        assertEquals("testuser", result.getUsername());
    }

    @Test
    void getUserByUsername_UserNotFound_ShouldThrowException() {
        // Given
        when(userRepository.findByUsername("nonexistent")).thenReturn(Optional.empty());

        // When & Then
        assertThrows(UsernameNotFoundException.class,
                () -> userService.getUserByUsername("nonexistent"));
    }
}


version: '3.8'

services:
  postgres:
    image: postgres:13-alpine
    container_name: bank-postgres
    environment:
      POSTGRES_DB: bankdb
      POSTGRES_USER: bankuser
      POSTGRES_PASSWORD: bankpass
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d
    networks:
      - bank-network

  app:
    build: .
    container_name: bank-app
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: dev
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/bankdb
      SPRING_DATASOURCE_USERNAME: bankuser
      SPRING_DATASOURCE_PASSWORD: bankpass
    depends_on:
      - postgres
    networks:
      - bank-network
    restart: unless-stopped

volumes:
  postgres_data:

networks:
  bank-network:
    driver: bridge


FROM eclipse-temurin:17-jre-alpine

RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} app.jar

ENTRYPOINT ["java", "-jar", "/app.jar"]


<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.bank</groupId>
    <artifactId>bank-rest</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <name>Bank REST API</name>
    <description>Bank Card Management System with JWT authentication</description>

    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>

        <!-- Dependency Versions -->
        <jjwt.version>0.11.5</jjwt.version>
        <springdoc.version>2.3.0</springdoc.version>
        <liquibase.version>4.24.0</liquibase.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Core Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>org.liquibase</groupId>
            <artifactId>liquibase-core</artifactId>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- OpenAPI Documentation -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>0.8.8</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>report</id>
                        <phase>test</phase>
                        <goals>
                            <goal>report</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

–≤—Å—ë –ø—Ä–æ–≤–µ—Ä—å, –≤—Å—ë –∏—Å–ø—Ä–∞–≤—å. —Ñ–∞–π–ª—ã –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–π –ø–æ–ª–Ω–æ—Å—Ç—å—é. –ü—Ä–æ–≤–µ—Ä—å –≤—Å—ë –ª–∏ –ø–æ —Ç–µ—Ö –∑–∞–¥–∞–Ω–∏—é. 
–ø—Ä–æ–≤–µ–¥–∏ –≤—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –∑–∞–ø—É—à—å: https://github.com/LacusFaustus/bank-rest